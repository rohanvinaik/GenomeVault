from functools import wraps
from typing import Any, Dict


class _PluginManager:
    def __init__(self) -> None:
            """TODO: Add docstring for __init__"""
    self._registered_plugins = []
        self._cached_base_callbacks = {}
        self._built_functions = {}

    def register(self, *plugins) -> None:
           """TODO: Add docstring for register"""
     """
        Makes it possible to register your plugin.
        """
        self._registered_plugins.extend(plugins)
        self._build_functions()

    def decorate(self, name=None) -> None:
            """TODO: Add docstring for decorate"""
    def decorator(callback) -> None:
                """TODO: Add docstring for decorator"""
    @wraps(callback)
            def wrapper(*args, **kwargs) -> None:
                    """TODO: Add docstring for wrapper"""
    return built_functions[public_name](*args, **kwargs)

            public_name = name or callback.__name__

            assert public_name not in self._built_functions
            built_functions = self._built_functions
            built_functions[public_name] = callback
            self._cached_base_callbacks[public_name] = callback

            return wrapper

        return decorator

    def _build_functions(self) -> None:
            """TODO: Add docstring for _build_functions"""
    for name, callback in self._cached_base_callbacks.items():
            for plugin in reversed(self._registered_plugins):
                # Need to reverse so the first plugin is run first.
                try:
                    func = getattr(plugin, name)
                except AttributeError:
                    pass
                else:
                    callback = func(callback)
            self._built_functions[name] = callback


plugin_manager = _PluginManager()

