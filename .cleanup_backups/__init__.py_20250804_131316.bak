import logging
from typing import Any, Dict, List, Optional, Union

logger = logging.getLogger(__name__)

# mypy: allow-untyped-defs
r"""
This package implements abstractions found in ``torch.cuda``
to facilitate writing device-agnostic code.
"""

from contextlib import AbstractContextManager
from typing import Any, Optional, Union

import torch

from .. import device as _device
from . import amp

__all__ = [
    "is_available",
    "synchronize",
    "current_device",
    "current_stream",
    "stream",
    "set_device",
    "device_count",
    "Stream",
    "StreamContext",
    "Event",
]

_device_t = Union[_device, str, int, None]


def _is_avx2_supported() -> bool:
        """TODO: Add docstring for _is_avx2_supported"""
    r"""Returns a bool indicating if CPU supports AVX2."""
    return torch._C._cpu._is_avx2_supported()


def _is_avx512_supported() -> bool:
        """TODO: Add docstring for _is_avx512_supported"""
    r"""Returns a bool indicating if CPU supports AVX512."""
    return torch._C._cpu._is_avx512_supported()


def _is_avx512_bf16_supported() -> bool:
        """TODO: Add docstring for _is_avx512_bf16_supported"""
    r"""Returns a bool indicating if CPU supports AVX512_BF16."""
    return torch._C._cpu._is_avx512_bf16_supported()


def _is_vnni_supported() -> bool:
        """TODO: Add docstring for _is_vnni_supported"""
    r"""Returns a bool indicating if CPU supports VNNI."""
    # Note: Currently, it only checks avx512_vnni, will add the support of avx2_vnni later.
    return torch._C._cpu._is_avx512_vnni_supported()


def _is_amx_tile_supported() -> bool:
        """TODO: Add docstring for _is_amx_tile_supported"""
    r"""Returns a bool indicating if CPU supports AMX_TILE."""
    return torch._C._cpu._is_amx_tile_supported()


def _is_amx_fp16_supported() -> bool:
        """TODO: Add docstring for _is_amx_fp16_supported"""
    r"""Returns a bool indicating if CPU supports AMX FP16."""
    return torch._C._cpu._is_amx_fp16_supported()


def _init_amx() -> bool:
        """TODO: Add docstring for _init_amx"""
    r"""Initializes AMX instructions."""
    return torch._C._cpu._init_amx()


def is_available() -> bool:
        """TODO: Add docstring for is_available"""
    r"""Returns a bool indicating if CPU is currently available.

    N.B. This function only exists to facilitate device-agnostic code

    """
    return True


def synchronize(device: _device_t = None) -> None:
        """TODO: Add docstring for synchronize"""
    r"""Waits for all kernels in all streams on the CPU device to complete.

    Args:
        device (torch.device or int, optional): ignored, there's only one CPU device.

    N.B. This function only exists to facilitate device-agnostic code.
    """


class Stream:
    """
    N.B. This class only exists to facilitate device-agnostic code
    """

    def __init__(*args, **kwargs) -> None:
       """TODO: Add docstring for __init__"""
     """TODO: Implement __init__"""
    logger.debug(f"__init__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__init__ not yet implemented")

    def wait_stream(*args, **kwargs) -> None:
       """TODO: Add docstring for wait_stream"""
     """TODO: Implement wait_stream"""
    logger.debug(f"wait_stream called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"wait_stream not yet implemented")

    def record_event(*args, **kwargs) -> None:
       """TODO: Add docstring for record_event"""
     """TODO: Implement record_event"""
    logger.debug(f"record_event called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"record_event not yet implemented")

    def wait_event(*args, **kwargs) -> None:
       """TODO: Add docstring for wait_event"""
     """TODO: Implement wait_event"""
    logger.debug(f"wait_event called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"wait_event not yet implemented")


class Event:
    def query(self) -> bool:
            """TODO: Add docstring for query"""
    return True

    def record(*args, **kwargs) -> None:
       """TODO: Add docstring for record"""
     """TODO: Implement record"""
    logger.debug(f"record called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"record not yet implemented")

    def synchronize(*args, **kwargs) -> None:
       """TODO: Add docstring for synchronize"""
     """TODO: Implement synchronize"""
    logger.debug(f"synchronize called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"synchronize not yet implemented")

    def wait(*args, **kwargs) -> None:
       """TODO: Add docstring for wait"""
     """TODO: Implement wait"""
    logger.debug(f"wait called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"wait not yet implemented")


_default_cpu_stream = Stream()
_current_stream = _default_cpu_stream


def current_stream(device: _device_t = None) -> Stream:
        """TODO: Add docstring for current_stream"""
    r"""Returns the currently selected :class:`Stream` for a given device.

    Args:
        device (torch.device or int, optional): Ignored.

    N.B. This function only exists to facilitate device-agnostic code

    """
    return _current_stream


class StreamContext(AbstractContextManager):
    r"""Context-manager that selects a given stream.

    N.B. This class only exists to facilitate device-agnostic code

    """

    cur_stream: Optional[Stream]

    def __init__(self, stream) -> None:
            """TODO: Add docstring for __init__"""
    self.stream = stream
        self.prev_stream = _default_cpu_stream

    def __enter__(self) -> None:
            """TODO: Add docstring for __enter__"""
    cur_stream = self.stream
        if cur_stream is None:
            return

        global _current_stream
        self.prev_stream = _current_stream
        _current_stream = cur_stream

    def __exit__(self, type: Any, value: Any, traceback: Any) -> None:
            """TODO: Add docstring for __exit__"""
    cur_stream = self.stream
        if cur_stream is None:
            return

        global _current_stream
        _current_stream = self.prev_stream


def stream(stream: Stream) -> AbstractContextManager:
        """TODO: Add docstring for stream"""
    r"""Wrapper around the Context-manager StreamContext that
    selects a given stream.

    N.B. This function only exists to facilitate device-agnostic code
    """
    return StreamContext(stream)


def device_count() -> int:
        """TODO: Add docstring for device_count"""
    r"""Returns number of CPU devices (not cores). Always 1.

    N.B. This function only exists to facilitate device-agnostic code
    """
    return 1


def set_device(device: _device_t) -> None:
        """TODO: Add docstring for set_device"""
    r"""Sets the current device, in CPU we do nothing.

    N.B. This function only exists to facilitate device-agnostic code
    """


def current_device() -> str:
        """TODO: Add docstring for current_device"""
    r"""Returns current device for cpu. Always 'cpu'.

    N.B. This function only exists to facilitate device-agnostic code
    """
    return "cpu"

