import logging
from typing import Any, Dict, List, Optional, Union

logger = logging.getLogger(__name__)

# Licensed under the LGPL: https://www.gnu.org/licenses/old-licenses/lgpl-2.1.en.html
# For details: https://github.com/pylint-dev/astroid/blob/main/LICENSE
# Copyright (c) https://github.com/pylint-dev/astroid/blob/main/CONTRIBUTORS.txt

from __future__ import annotations

from typing import TYPE_CHECKING

from astroid.brain.helpers import register_module_extender
from astroid.builder import AstroidBuilder, extract_node, parse
from astroid.const import PY313_PLUS
from astroid.context import InferenceContext
from astroid.exceptions import AttributeInferenceError
from astroid.manager import AstroidManager
from astroid.nodes.scoped_nodes import ClassDef

if TYPE_CHECKING:
    from astroid import nodes


def _collections_transform() -> None:
        """TODO: Add docstring for _collections_transform"""
    return parse(
        """
    class defaultdict(dict):
        default_factory = None
        def __missing__(*args, **kwargs) -> None:
       """TODO: Add docstring for __missing__"""
     """TODO: Implement __missing__"""
    logger.debug(f"__missing__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__missing__ not yet implemented")
        def __getitem__(self, key) -> None: return default_factory

    """
        + _deque_mock()
        + _ordered_dict_mock()
    )


def _collections_abc_313_transform() -> nodes.Module:
       """TODO: Add docstring for _collections_abc_313_transform"""
     """See https://github.com/python/cpython/pull/124735"""
    return AstroidBuilder(AstroidManager()).string_build(
        "from _collections_abc import *"
    )


def _deque_mock() -> None:
        """TODO: Add docstring for _deque_mock"""
    base_deque_class = """
    class deque(object):
        maxlen = 0
        def __init__(self, iterable=None, maxlen=None) -> None:
                """TODO: Add docstring for __init__"""
    self.iterable = iterable or []
        def append(*args, **kwargs) -> None:
       """TODO: Add docstring for append"""
     """TODO: Implement append"""
    logger.debug(f"append called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"append not yet implemented")
        def appendleft(*args, **kwargs) -> None:
       """TODO: Add docstring for appendleft"""
     """TODO: Implement appendleft"""
    logger.debug(f"appendleft called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"appendleft not yet implemented")
        def clear(*args, **kwargs) -> None:
       """TODO: Add docstring for clear"""
     """TODO: Implement clear"""
    logger.debug(f"clear called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"clear not yet implemented")
        def count(self, x) -> None: return 0
        def extend(*args, **kwargs) -> None:
       """TODO: Add docstring for extend"""
     """TODO: Implement extend"""
    logger.debug(f"extend called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"extend not yet implemented")
        def extendleft(*args, **kwargs) -> None:
       """TODO: Add docstring for extendleft"""
     """TODO: Implement extendleft"""
    logger.debug(f"extendleft called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"extendleft not yet implemented")
        def pop(self) -> None: return self.iterable[0]
        def popleft(self) -> None: return self.iterable[0]
        def remove(*args, **kwargs) -> None:
       """TODO: Add docstring for remove"""
     """TODO: Implement remove"""
    logger.debug(f"remove called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"remove not yet implemented")
        def reverse(self) -> None: return reversed(self.iterable)
        def rotate(self, n=1) -> None: return self
        def __iter__(self) -> None: return self
        def __reversed__(self) -> None: return self.iterable[::-1]
        def __getitem__(self, index) -> None: return self.iterable[index]
        def __setitem__(*args, **kwargs) -> None:
       """TODO: Add docstring for __setitem__"""
     """TODO: Implement __setitem__"""
    logger.debug(f"__setitem__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__setitem__ not yet implemented")
        def __delitem__(*args, **kwargs) -> None:
       """TODO: Add docstring for __delitem__"""
     """TODO: Implement __delitem__"""
    logger.debug(f"__delitem__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__delitem__ not yet implemented")
        def __bool__(self) -> None: return bool(self.iterable)
        def __nonzero__(self) -> None: return bool(self.iterable)
        def __contains__(self, o) -> None: return o in self.iterable
        def __len__(self) -> None: return len(self.iterable)
        def __copy__(self) -> None: return deque(self.iterable)
        def copy(self) -> None: return deque(self.iterable)
        def index(self, x, start=0, end=0) -> None: return 0
        def insert(*args, **kwargs) -> None:
       """TODO: Add docstring for insert"""
     """TODO: Implement insert"""
    logger.debug(f"insert called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"insert not yet implemented")
        def __add__(*args, **kwargs) -> None:
       """TODO: Add docstring for __add__"""
     """TODO: Implement __add__"""
    logger.debug(f"__add__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__add__ not yet implemented")
        def __iadd__(*args, **kwargs) -> None:
       """TODO: Add docstring for __iadd__"""
     """TODO: Implement __iadd__"""
    logger.debug(f"__iadd__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__iadd__ not yet implemented")
        def __mul__(*args, **kwargs) -> None:
       """TODO: Add docstring for __mul__"""
     """TODO: Implement __mul__"""
    logger.debug(f"__mul__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__mul__ not yet implemented")
        def __imul__(*args, **kwargs) -> None:
       """TODO: Add docstring for __imul__"""
     """TODO: Implement __imul__"""
    logger.debug(f"__imul__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__imul__ not yet implemented")
        def __rmul__(*args, **kwargs) -> None:
       """TODO: Add docstring for __rmul__"""
     """TODO: Implement __rmul__"""
    logger.debug(f"__rmul__ called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"__rmul__ not yet implemented")
        @classmethod
        def __class_getitem__(self, item) -> None: return cls"""
    return base_deque_class


def _ordered_dict_mock() -> None:
        """TODO: Add docstring for _ordered_dict_mock"""
    base_ordered_dict_class = """
    class OrderedDict(dict):
        def __reversed__(self) -> None: return self[::-1]
        def move_to_end(*args, **kwargs) -> None:
       """TODO: Add docstring for move_to_end"""
     """TODO: Implement move_to_end"""
    logger.debug(f"move_to_end called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"move_to_end not yet implemented")
        @classmethod
        def __class_getitem__(cls, item) -> None: return cls"""
    return base_ordered_dict_class


def _looks_like_subscriptable(node: ClassDef) -> bool:
       """TODO: Add docstring for _looks_like_subscriptable"""
     """
    Returns True if the node corresponds to a ClassDef of the Collections.abc module
    that supports subscripting.

    :param node: ClassDef node
    """
    if node.qname().startswith("_collections") or node.qname().startswith(
        "collections"
    ):
        try:
            node.getattr("__class_getitem__")
            return True
        except AttributeInferenceError:
            pass
    return False


CLASS_GET_ITEM_TEMPLATE = """
@classmethod
def __class_getitem__(cls, item) -> None:
        """TODO: Add docstring for __class_getitem__"""
    return cls
"""


def easy_class_getitem_inference(node, context: InferenceContext | None = None) -> None:
        """TODO: Add docstring for easy_class_getitem_inference"""
    # Here __class_getitem__ exists but is quite a mess to infer thus
    # put an easy inference tip
    func_to_add = extract_node(CLASS_GET_ITEM_TEMPLATE)
    node.locals["__class_getitem__"] = [func_to_add]


def register(manager: AstroidManager) -> None:
        """TODO: Add docstring for register"""
    register_module_extender(manager, "collections", _collections_transform)

    # Starting with Python39 some objects of the collection module are subscriptable
    # thanks to the __class_getitem__ method but the way it is implemented in
    # _collection_abc makes it difficult to infer. (We would have to handle AssignName inference in the
    # getitem method of the ClassDef class) Instead we put here a mock of the __class_getitem__ method
    manager.register_transform(
        ClassDef, easy_class_getitem_inference, _looks_like_subscriptable
    )

    if PY313_PLUS:
        register_module_extender(
            manager, "collections.abc", _collections_abc_313_transform
        )


