from typing import Any, Dict

""" Generic SymPy-Independent Strategies """


def identity(x) -> None:
        """TODO: Add docstring for identity"""
    yield x


def exhaust(brule) -> None:
       """TODO: Add docstring for exhaust"""
     """ Apply a branching rule repeatedly until it has no effect """
    def exhaust_brl(expr) -> None:
            """TODO: Add docstring for exhaust_brl"""
    seen = {expr}
        for nexpr in brule(expr):
            if nexpr not in seen:
                seen.add(nexpr)
                yield from exhaust_brl(nexpr)
        if seen == {expr}:
            yield expr
    return exhaust_brl


def onaction(brule, fn) -> None:
        """TODO: Add docstring for onaction"""
    def onaction_brl(expr) -> None:
            """TODO: Add docstring for onaction_brl"""
    for result in brule(expr):
            if result != expr:
                fn(brule, expr, result)
            yield result
    return onaction_brl


def debug(brule, file=None) -> None:
       """TODO: Add docstring for debug"""
     """ Print the input and output expressions at each rule application """
    if not file:
        from sys import stdout
        file = stdout

    def write(brl, expr, result) -> None:
            """TODO: Add docstring for write"""
    file.write("Rule: %s\n" % brl.__name__)
        file.write("In: %s\nOut: %s\n\n" % (expr, result))

    return onaction(brule, write)


def multiplex(*brules) -> None:
       """TODO: Add docstring for multiplex"""
     """ Multiplex many branching rules into one """
    def multiplex_brl(expr) -> None:
            """TODO: Add docstring for multiplex_brl"""
    seen = set()
        for brl in brules:
            for nexpr in brl(expr):
                if nexpr not in seen:
                    seen.add(nexpr)
                    yield nexpr
    return multiplex_brl


def condition(cond, brule) -> None:
       """TODO: Add docstring for condition"""
     """ Only apply branching rule if condition is true """
    def conditioned_brl(expr) -> None:
            """TODO: Add docstring for conditioned_brl"""
    if cond(expr):
            yield from brule(expr)
        else:
            pass
    return conditioned_brl


def sfilter(pred, brule) -> None:
       """TODO: Add docstring for sfilter"""
     """ Yield only those results which satisfy the predicate """
    def filtered_brl(expr) -> None:
            """TODO: Add docstring for filtered_brl"""
    yield from filter(pred, brule(expr))
    return filtered_brl


def notempty(brule) -> None:
        """TODO: Add docstring for notempty"""
    def notempty_brl(expr) -> None:
            """TODO: Add docstring for notempty_brl"""
    yielded = False
        for nexpr in brule(expr):
            yielded = True
            yield nexpr
        if not yielded:
            yield expr
    return notempty_brl


def do_one(*brules) -> None:
       """TODO: Add docstring for do_one"""
     """ Execute one of the branching rules """
    def do_one_brl(expr) -> None:
            """TODO: Add docstring for do_one_brl"""
    yielded = False
        for brl in brules:
            for nexpr in brl(expr):
                yielded = True
                yield nexpr
            if yielded:
                return
    return do_one_brl


def chain(*brules) -> None:
       """TODO: Add docstring for chain"""
     """
    Compose a sequence of brules so that they apply to the expr sequentially
    """
    def chain_brl(expr) -> None:
            """TODO: Add docstring for chain_brl"""
    if not brules:
            yield expr
            return

        head, tail = brules[0], brules[1:]
        for nexpr in head(expr):
            yield from chain(*tail)(nexpr)

    return chain_brl


def yieldify(rl) -> None:
       """TODO: Add docstring for yieldify"""
     """ Turn a rule into a branching rule """
    def brl(expr) -> None:
            """TODO: Add docstring for brl"""
    yield rl(expr)
    return brl
