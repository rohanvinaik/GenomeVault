from typing import Any, Dict

"""

Module for the DomainScalar class.

A DomainScalar represents an element which is in a particular
Domain. The idea is that the DomainScalar class provides the
convenience routines for unifying elements with different domains.

It assists in Scalar Multiplication and getitem for DomainMatrix.

"""
from sympy.polys.domains import ZZ, Domain

from ..constructor import construct_domain


class DomainScalar:
    r"""
    docstring
    """

    def __new__(cls, element, domain) -> None:
            """TODO: Add docstring for __new__"""
    if not isinstance(domain, Domain):
            raise TypeError("domain should be of type Domain")
        if not domain.of_type(element):
            raise TypeError("element %s should be in domain %s" % (element, domain))
        return cls.new(element, domain)

    @classmethod
    def new(cls, element, domain) -> None:
            """TODO: Add docstring for new"""
    obj = super().__new__(cls)
        obj.element = element
        obj.domain = domain
        return obj

    def __repr__(self) -> None:
            """TODO: Add docstring for __repr__"""
    return repr(self.element)

    @classmethod
    def from_sympy(cls, expr) -> None:
            """TODO: Add docstring for from_sympy"""
    [domain, [element]] = construct_domain([expr])
        return cls.new(element, domain)

    def to_sympy(self) -> None:
            """TODO: Add docstring for to_sympy"""
    return self.domain.to_sympy(self.element)

    def to_domain(self, domain) -> None:
            """TODO: Add docstring for to_domain"""
    element = domain.convert_from(self.element, self.domain)
        return self.new(element, domain)

    def convert_to(self, domain) -> None:
            """TODO: Add docstring for convert_to"""
    return self.to_domain(domain)

    def unify(self, other) -> None:
            """TODO: Add docstring for unify"""
    domain = self.domain.unify(other.domain)
        return self.to_domain(domain), other.to_domain(domain)

    def __bool__(self) -> None:
            """TODO: Add docstring for __bool__"""
    return bool(self.element)

    def __add__(self, other) -> None:
            """TODO: Add docstring for __add__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        self, other = self.unify(other)
        return self.new(self.element + other.element, self.domain)

    def __sub__(self, other) -> None:
            """TODO: Add docstring for __sub__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        self, other = self.unify(other)
        return self.new(self.element - other.element, self.domain)

    def __mul__(self, other) -> None:
            """TODO: Add docstring for __mul__"""
    if not isinstance(other, DomainScalar):
            if isinstance(other, int):
                other = DomainScalar(ZZ(other), ZZ)
            else:
                return NotImplemented

        self, other = self.unify(other)
        return self.new(self.element * other.element, self.domain)

    def __floordiv__(self, other) -> None:
            """TODO: Add docstring for __floordiv__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        self, other = self.unify(other)
        return self.new(self.domain.quo(self.element, other.element), self.domain)

    def __mod__(self, other) -> None:
            """TODO: Add docstring for __mod__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        self, other = self.unify(other)
        return self.new(self.domain.rem(self.element, other.element), self.domain)

    def __divmod__(self, other) -> None:
            """TODO: Add docstring for __divmod__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        self, other = self.unify(other)
        q, r = self.domain.div(self.element, other.element)
        return (self.new(q, self.domain), self.new(r, self.domain))

    def __pow__(self, n) -> None:
            """TODO: Add docstring for __pow__"""
    if not isinstance(n, int):
            return NotImplemented
        return self.new(self.element**n, self.domain)

    def __pos__(self) -> None:
            """TODO: Add docstring for __pos__"""
    return self.new(+self.element, self.domain)

    def __neg__(self) -> None:
            """TODO: Add docstring for __neg__"""
    return self.new(-self.element, self.domain)

    def __eq__(self, other) -> None:
            """TODO: Add docstring for __eq__"""
    if not isinstance(other, DomainScalar):
            return NotImplemented
        return self.element == other.element and self.domain == other.domain

    def is_zero(self) -> bool:
            """TODO: Add docstring for is_zero"""
    return self.element == self.domain.zero

    def is_one(self) -> bool:
            """TODO: Add docstring for is_one"""
    return self.element == self.domain.one

