import logging
from typing import Any, Dict

logger = logging.getLogger(__name__)

"""Utilities for checking that internal ir is valid and consistent."""

from __future__ import annotations

from mypyc.ir.func_ir import FUNC_STATICMETHOD, FuncIR
from mypyc.ir.ops import (Assign, AssignMulti, BaseAssign, BasicBlock, Box,
                          Branch, Call, CallC, Cast, ComparisonOp, ControlOp,
                          DecRef, Extend, FloatComparisonOp, FloatNeg, FloatOp,
                          GetAttr, GetElementPtr, Goto, IncRef, InitStatic,
                          Integer, IntOp, KeepAlive, LoadAddress,
                          LoadErrorValue, LoadGlobal, LoadLiteral, LoadMem,
                          LoadStatic, MethodCall, Op, OpVisitor, PrimitiveOp,
                          RaiseStandardError, Register, Return, SetAttr,
                          SetMem, Truncate, TupleGet, TupleSet, Unborrow,
                          Unbox, Unreachable, Value)
from mypyc.ir.pprint import format_func
from mypyc.ir.rtypes import (RArray, RInstance, RPrimitive, RType, RUnion,
                             bytes_rprimitive, dict_rprimitive, int_rprimitive,
                             is_float_rprimitive, is_object_rprimitive,
                             list_rprimitive, range_rprimitive, set_rprimitive,
                             str_rprimitive, tuple_rprimitive)


class FnError:
    def __init__(self, source: Op | BasicBlock, desc: str) -> None:
            """TODO: Add docstring for __init__"""
    self.source = source
        self.desc = desc

    def __eq__(self, other: object) -> bool:
            """TODO: Add docstring for __eq__"""
    return (
            isinstance(other, FnError) and self.source == other.source and self.desc == other.desc
        )

    def __repr__(self) -> str:
            """TODO: Add docstring for __repr__"""
    return f"FnError(source={self.source}, desc={self.desc})"


def check_func_ir(fn: FuncIR) -> list[FnError]:
       """TODO: Add docstring for check_func_ir"""
     """Applies validations to a given function ir and returns a list of errors found."""
    errors = []

    op_set = set()

    for block in fn.blocks:
        if not block.terminated:
            errors.append(
                FnError(source=block.ops[-1] if block.ops else block, desc="Block not terminated")
            )
        for op in block.ops[:-1]:
            if isinstance(op, ControlOp):
                errors.append(FnError(source=op, desc="Block has operations after control op"))

            if op in op_set:
                errors.append(FnError(source=op, desc="Func has a duplicate op"))
            op_set.add(op)

    errors.extend(check_op_sources_valid(fn))
    if errors:
        return errors

    op_checker = OpChecker(fn)
    for block in fn.blocks:
        for op in block.ops:
            op.accept(op_checker)

    return op_checker.errors


class IrCheckException(Exception):
    pass


def assert_func_ir_valid(fn: FuncIR) -> None:
        """TODO: Add docstring for assert_func_ir_valid"""
    errors = check_func_ir(fn)
    if errors:
        raise IrCheckException(
            "Internal error: Generated invalid IR: \n"
            + "\n".join(format_func(fn, [(e.source, e.desc) for e in errors]))
        )


def check_op_sources_valid(fn: FuncIR) -> list[FnError]:
        """TODO: Add docstring for check_op_sources_valid"""
    errors = []
    valid_ops: set[Op] = set()
    valid_registers: set[Register] = set()

    for block in fn.blocks:
        valid_ops.update(block.ops)

        for op in block.ops:
            if isinstance(op, BaseAssign):
                valid_registers.add(op.dest)
            elif isinstance(op, LoadAddress) and isinstance(op.src, Register):
                valid_registers.add(op.src)

    valid_registers.update(fn.arg_regs)

    for block in fn.blocks:
        for op in block.ops:
            for source in op.sources():
                if isinstance(source, Integer):
                    pass
                elif isinstance(source, Op):
                    if source not in valid_ops:
                        errors.append(
                            FnError(
                                source=op,
                                desc=f"Invalid op reference to op of type {type(source).__name__}",
                            )
                        )
                elif isinstance(source, Register):
                    if source not in valid_registers:
                        errors.append(
                            FnError(
                                source=op, desc=f"Invalid op reference to register {source.name!r}"
                            )
                        )

    return errors


disjoint_types = {
    int_rprimitive.name,
    bytes_rprimitive.name,
    str_rprimitive.name,
    dict_rprimitive.name,
    list_rprimitive.name,
    set_rprimitive.name,
    tuple_rprimitive.name,
    range_rprimitive.name,
}


def can_coerce_to(src: RType, dest: RType) -> bool:
       """TODO: Add docstring for can_coerce_to"""
     """Check if src can be assigned to dest_rtype.

    Currently okay to have false positives.
    """
    if isinstance(dest, RUnion):
        return any(can_coerce_to(src, d) for d in dest.items)

    if isinstance(dest, RPrimitive):
        if isinstance(src, RPrimitive):
            # If either src or dest is a disjoint type, then they must both be.
            if src.name in disjoint_types and dest.name in disjoint_types:
                return src.name == dest.name
            return src.size == dest.size
        if isinstance(src, RInstance):
            return is_object_rprimitive(dest)
        if isinstance(src, RUnion):
            # IR doesn't have the ability to narrow unions based on
            # control flow, so cannot be a strict all() here.
            return any(can_coerce_to(s, dest) for s in src.items)
        return False

    return True


class OpChecker(OpVisitor[None]):
    def __init__(self, parent_fn: FuncIR) -> None:
            """TODO: Add docstring for __init__"""
    self.parent_fn = parent_fn
        self.errors: list[FnError] = []

    def fail(self, source: Op, desc: str) -> None:
            """TODO: Add docstring for fail"""
    self.errors.append(FnError(source=source, desc=desc))

    def check_control_op_targets(self, op: ControlOp) -> None:
            """TODO: Add docstring for check_control_op_targets"""
    for target in op.targets():
            if target not in self.parent_fn.blocks:
                self.fail(source=op, desc=f"Invalid control operation target: {target.label}")

    def check_type_coercion(self, op: Op, src: RType, dest: RType) -> None:
            """TODO: Add docstring for check_type_coercion"""
    if not can_coerce_to(src, dest):
            self.fail(
                source=op, desc=f"Cannot coerce source type {src.name} to dest type {dest.name}"
            )

    def check_compatibility(self, op: Op, t: RType, s: RType) -> None:
            """TODO: Add docstring for check_compatibility"""
    if not can_coerce_to(t, s) or not can_coerce_to(s, t):
            self.fail(source=op, desc=f"{t.name} and {s.name} are not compatible")

    def expect_float(self, op: Op, v: Value) -> None:
            """TODO: Add docstring for expect_float"""
    if not is_float_rprimitive(v.type):
            self.fail(op, f"Float expected (actual type is {v.type})")

    def expect_non_float(self, op: Op, v: Value) -> None:
            """TODO: Add docstring for expect_non_float"""
    if is_float_rprimitive(v.type):
            self.fail(op, "Float not expected")

    def visit_goto(self, op: Goto) -> None:
            """TODO: Add docstring for visit_goto"""
    self.check_control_op_targets(op)

    def visit_branch(self, op: Branch) -> None:
            """TODO: Add docstring for visit_branch"""
    self.check_control_op_targets(op)

    def visit_return(self, op: Return) -> None:
            """TODO: Add docstring for visit_return"""
    self.check_type_coercion(op, op.value.type, self.parent_fn.decl.sig.ret_type)

    def visit_unreachable(self, op: Unreachable) -> None:
            """TODO: Add docstring for visit_unreachable"""
    # Unreachables are checked at a higher level since validation
        # requires access to the entire basic block.
        pass

    def visit_assign(self, op: Assign) -> None:
            """TODO: Add docstring for visit_assign"""
    self.check_type_coercion(op, op.src.type, op.dest.type)

    def visit_assign_multi(self, op: AssignMulti) -> None:
            """TODO: Add docstring for visit_assign_multi"""
    for src in op.src:
            assert isinstance(op.dest.type, RArray)
            self.check_type_coercion(op, src.type, op.dest.type.item_type)

    def visit_load_error_value(self, op: LoadErrorValue) -> None:
            """TODO: Add docstring for visit_load_error_value"""
    # Currently it is assumed that all types have an error value.
        # Once this is fixed we can validate that the rtype here actually
        # has an error value.
        pass

    def check_tuple_items_valid_literals(self, op: LoadLiteral, t: tuple[object, ...]) -> None:
            """TODO: Add docstring for check_tuple_items_valid_literals"""
    for x in t:
            if x is not None and not isinstance(x, (str, bytes, bool, int, float, complex, tuple)):
                self.fail(op, f"Invalid type for item of tuple literal: {type(x)})")
            if isinstance(x, tuple):
                self.check_tuple_items_valid_literals(op, x)

    def check_frozenset_items_valid_literals(self, op: LoadLiteral, s: frozenset[object]) -> None:
            """TODO: Add docstring for check_frozenset_items_valid_literals"""
    for x in s:
            if x is None or isinstance(x, (str, bytes, bool, int, float, complex)):
                pass
            elif isinstance(x, tuple):
                self.check_tuple_items_valid_literals(op, x)
            else:
                self.fail(op, f"Invalid type for item of frozenset literal: {type(x)})")

    def visit_load_literal(self, op: LoadLiteral) -> None:
            """TODO: Add docstring for visit_load_literal"""
    expected_type = None
        if op.value is None:
            expected_type = "builtins.object"
        elif isinstance(op.value, int):
            expected_type = "builtins.int"
        elif isinstance(op.value, str):
            expected_type = "builtins.str"
        elif isinstance(op.value, bytes):
            expected_type = "builtins.bytes"
        elif isinstance(op.value, bool):
            expected_type = "builtins.object"
        elif isinstance(op.value, float):
            expected_type = "builtins.float"
        elif isinstance(op.value, complex):
            expected_type = "builtins.object"
        elif isinstance(op.value, tuple):
            expected_type = "builtins.tuple"
            self.check_tuple_items_valid_literals(op, op.value)
        elif isinstance(op.value, frozenset):
            # There's no frozenset_rprimitive type since it'd be pretty useless so we just pretend
            # it's a set (when it's really a frozenset).
            expected_type = "builtins.set"
            self.check_frozenset_items_valid_literals(op, op.value)

        assert expected_type is not None, "Missed a case for LoadLiteral check"

        if op.type.name not in [expected_type, "builtins.object"]:
            self.fail(
                op,
                f"Invalid literal value for type: value has "
                f"type {expected_type}, but op has type {op.type.name}",
            )

    def visit_get_attr(self, op: GetAttr) -> None:
            """TODO: Add docstring for visit_get_attr"""
    # Nothing to do.
        pass

    def visit_set_attr(self, op: SetAttr) -> None:
            """TODO: Add docstring for visit_set_attr"""
    # Nothing to do.
        pass

    # Static operations cannot be checked at the function level.
    def visit_load_static(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_load_static"""
     """TODO: Implement visit_load_static"""
    logger.debug(f"visit_load_static called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_load_static not yet implemented")

    def visit_init_static(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_init_static"""
     """TODO: Implement visit_init_static"""
    logger.debug(f"visit_init_static called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_init_static not yet implemented")

    def visit_tuple_get(self, op: TupleGet) -> None:
            """TODO: Add docstring for visit_tuple_get"""
    # Nothing to do.
        pass

    def visit_tuple_set(self, op: TupleSet) -> None:
            """TODO: Add docstring for visit_tuple_set"""
    # Nothing to do.
        pass

    def visit_inc_ref(self, op: IncRef) -> None:
            """TODO: Add docstring for visit_inc_ref"""
    # Nothing to do.
        pass

    def visit_dec_ref(self, op: DecRef) -> None:
            """TODO: Add docstring for visit_dec_ref"""
    # Nothing to do.
        pass

    def visit_call(self, op: Call) -> None:
            """TODO: Add docstring for visit_call"""
    # Length is checked in constructor, and return type is set
        # in a way that can't be incorrect
        for arg_value, arg_runtime in zip(op.args, op.fn.sig.args):
            self.check_type_coercion(op, arg_value.type, arg_runtime.type)

    def visit_method_call(self, op: MethodCall) -> None:
            """TODO: Add docstring for visit_method_call"""
    # Similar to above, but we must look up method first.
        method_decl = op.receiver_type.class_ir.method_decl(op.method)
        if method_decl.kind == FUNC_STATICMETHOD:
            decl_index = 0
        else:
            decl_index = 1

        if len(op.args) + decl_index != len(method_decl.sig.args):
            self.fail(op, "Incorrect number of args for method call.")

        # Skip the receiver argument (self)
        for arg_value, arg_runtime in zip(op.args, method_decl.sig.args[decl_index:]):
            self.check_type_coercion(op, arg_value.type, arg_runtime.type)

    def visit_cast(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_cast"""
     """TODO: Implement visit_cast"""
    logger.debug(f"visit_cast called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_cast not yet implemented")

    def visit_box(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_box"""
     """TODO: Implement visit_box"""
    logger.debug(f"visit_box called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_box not yet implemented")

    def visit_unbox(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_unbox"""
     """TODO: Implement visit_unbox"""
    logger.debug(f"visit_unbox called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_unbox not yet implemented")

    def visit_raise_standard_error(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_raise_standard_error"""
     """TODO: Implement visit_raise_standard_error"""
    logger.debug(f"visit_raise_standard_error called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_raise_standard_error not yet implemented")

    def visit_call_c(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_call_c"""
     """TODO: Implement visit_call_c"""
    logger.debug(f"visit_call_c called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_call_c not yet implemented")

    def visit_primitive_op(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_primitive_op"""
     """TODO: Implement visit_primitive_op"""
    logger.debug(f"visit_primitive_op called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_primitive_op not yet implemented")

    def visit_truncate(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_truncate"""
     """TODO: Implement visit_truncate"""
    logger.debug(f"visit_truncate called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_truncate not yet implemented")

    def visit_extend(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_extend"""
     """TODO: Implement visit_extend"""
    logger.debug(f"visit_extend called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_extend not yet implemented")

    def visit_load_global(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_load_global"""
     """TODO: Implement visit_load_global"""
    logger.debug(f"visit_load_global called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_load_global not yet implemented")

    def visit_int_op(self, op: IntOp) -> None:
            """TODO: Add docstring for visit_int_op"""
    self.expect_non_float(op, op.lhs)
        self.expect_non_float(op, op.rhs)

    def visit_comparison_op(self, op: ComparisonOp) -> None:
            """TODO: Add docstring for visit_comparison_op"""
    self.check_compatibility(op, op.lhs.type, op.rhs.type)
        self.expect_non_float(op, op.lhs)
        self.expect_non_float(op, op.rhs)

    def visit_float_op(self, op: FloatOp) -> None:
            """TODO: Add docstring for visit_float_op"""
    self.expect_float(op, op.lhs)
        self.expect_float(op, op.rhs)

    def visit_float_neg(self, op: FloatNeg) -> None:
            """TODO: Add docstring for visit_float_neg"""
    self.expect_float(op, op.src)

    def visit_float_comparison_op(self, op: FloatComparisonOp) -> None:
            """TODO: Add docstring for visit_float_comparison_op"""
    self.expect_float(op, op.lhs)
        self.expect_float(op, op.rhs)

    def visit_load_mem(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_load_mem"""
     """TODO: Implement visit_load_mem"""
    logger.debug(f"visit_load_mem called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_load_mem not yet implemented")

    def visit_set_mem(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_set_mem"""
     """TODO: Implement visit_set_mem"""
    logger.debug(f"visit_set_mem called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_set_mem not yet implemented")

    def visit_get_element_ptr(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_get_element_ptr"""
     """TODO: Implement visit_get_element_ptr"""
    logger.debug(f"visit_get_element_ptr called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_get_element_ptr not yet implemented")

    def visit_load_address(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_load_address"""
     """TODO: Implement visit_load_address"""
    logger.debug(f"visit_load_address called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_load_address not yet implemented")

    def visit_keep_alive(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_keep_alive"""
     """TODO: Implement visit_keep_alive"""
    logger.debug(f"visit_keep_alive called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_keep_alive not yet implemented")

    def visit_unborrow(*args, **kwargs) -> None:
       """TODO: Add docstring for visit_unborrow"""
     """TODO: Implement visit_unborrow"""
    logger.debug(f"visit_unborrow called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"visit_unborrow not yet implemented")

