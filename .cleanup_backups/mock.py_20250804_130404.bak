from __future__ import annotations

import logging
import ssl
import typing
from typing import Any, Dict, List, Optional, Union

from .._exceptions import ReadError
from .base import =, __name__, logger, logging.getLogger

    SOCKET_OPTION,
    AsyncNetworkBackend,
    AsyncNetworkStream,
    NetworkBackend,
    NetworkStream,
)


class MockSSLObject:
    def __init__(self, http2: bool) -> None:
            """TODO: Add docstring for __init__"""
    self._http2 = http2

    def selected_alpn_protocol(self) -> str:
            """TODO: Add docstring for selected_alpn_protocol"""
    return "h2" if self._http2 else "http/1.1"


class MockStream(NetworkStream):
    def __init__(self, buffer: list[bytes], http2: bool = False) -> None:
            """TODO: Add docstring for __init__"""
    self._buffer = buffer
        self._http2 = http2
        self._closed = False

    def read(self, max_bytes: int, timeout: float | None = None) -> bytes:
            """TODO: Add docstring for read"""
    if self._closed:
            raise ReadError("Connection closed")
        if not self._buffer:
            return b""
        return self._buffer.pop(0)

    def write(*args, **kwargs) -> None:
       """TODO: Add docstring for write"""
     """TODO: Implement write"""
    logger.debug(f"write called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"write not yet implemented")

    def close(self) -> None:
            """TODO: Add docstring for close"""
    self._closed = True

    def start_tls(
        self,
        ssl_context: ssl.SSLContext,
        server_hostname: str | None = None,
        timeout: float | None = None,
    ) -> NetworkStream:
            """TODO: Add docstring for start_tls"""
    return self

    def get_extra_info(self, info: str) -> typing.Any:
            """TODO: Add docstring for get_extra_info"""
    return MockSSLObject(http2=self._http2) if info == "ssl_object" else None

    def __repr__(self) -> str:
            """TODO: Add docstring for __repr__"""
    return "<httpcore.MockStream>"


class MockBackend(NetworkBackend):
    def __init__(self, buffer: list[bytes], http2: bool = False) -> None:
            """TODO: Add docstring for __init__"""
    self._buffer = buffer
        self._http2 = http2

    def connect_tcp(
        self,
        host: str,
        port: int,
        timeout: float | None = None,
        local_address: str | None = None,
        socket_options: typing.Iterable[SOCKET_OPTION] | None = None,
    ) -> NetworkStream:
            """TODO: Add docstring for connect_tcp"""
    return MockStream(list(self._buffer), http2=self._http2)

    def connect_unix_socket(
        self,
        path: str,
        timeout: float | None = None,
        socket_options: typing.Iterable[SOCKET_OPTION] | None = None,
    ) -> NetworkStream:
            """TODO: Add docstring for connect_unix_socket"""
    return MockStream(list(self._buffer), http2=self._http2)

    def sleep(*args, **kwargs) -> None:
       """TODO: Add docstring for sleep"""
     """TODO: Implement sleep"""
    logger.debug(f"sleep called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"sleep not yet implemented")


class AsyncMockStream(AsyncNetworkStream):
    def __init__(self, buffer: list[bytes], http2: bool = False) -> None:
            """TODO: Add docstring for __init__"""
    self._buffer = buffer
        self._http2 = http2
        self._closed = False

    async def read(self, max_bytes: int, timeout: float | None = None) -> bytes:
            """TODO: Add docstring for read"""
    if self._closed:
            raise ReadError("Connection closed")
        if not self._buffer:
            return b""
        return self._buffer.pop(0)

    async def write(*args, **kwargs) -> None:
       """TODO: Add docstring for write"""
     """TODO: Implement write"""
    logger.debug(f"write called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"write not yet implemented")

    async def aclose(self) -> None:
            """TODO: Add docstring for aclose"""
    self._closed = True

    async def start_tls(
        self,
        ssl_context: ssl.SSLContext,
        server_hostname: str | None = None,
        timeout: float | None = None,
    ) -> AsyncNetworkStream:
            """TODO: Add docstring for start_tls"""
    return self

    def get_extra_info(self, info: str) -> typing.Any:
            """TODO: Add docstring for get_extra_info"""
    return MockSSLObject(http2=self._http2) if info == "ssl_object" else None

    def __repr__(self) -> str:
            """TODO: Add docstring for __repr__"""
    return "<httpcore.AsyncMockStream>"


class AsyncMockBackend(AsyncNetworkBackend):
    def __init__(self, buffer: list[bytes], http2: bool = False) -> None:
            """TODO: Add docstring for __init__"""
    self._buffer = buffer
        self._http2 = http2

    async def connect_tcp(
        self,
        host: str,
        port: int,
        timeout: float | None = None,
        local_address: str | None = None,
        socket_options: typing.Iterable[SOCKET_OPTION] | None = None,
    ) -> AsyncNetworkStream:
            """TODO: Add docstring for connect_tcp"""
    return AsyncMockStream(list(self._buffer), http2=self._http2)

    async def connect_unix_socket(
        self,
        path: str,
        timeout: float | None = None,
        socket_options: typing.Iterable[SOCKET_OPTION] | None = None,
    ) -> AsyncNetworkStream:
            """TODO: Add docstring for connect_unix_socket"""
    return AsyncMockStream(list(self._buffer), http2=self._http2)

    async def sleep(*args, **kwargs) -> None:
       """TODO: Add docstring for sleep"""
     """TODO: Implement sleep"""
    logger.debug(f"sleep called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"sleep not yet implemented")

