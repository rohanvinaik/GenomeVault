"""Implementation of :class:`ModularInteger` class. """

from __future__ import annotations

import operator
from typing import Any

from sympy.polys.domains.domainelement import DomainElement
from sympy.polys.polyerrors import CoercionFailed
from sympy.polys.polyutils import PicklableWithSlots
from sympy.utilities import public
from sympy.utilities.exceptions import sympy_deprecation_warning


@public
class ModularInteger(PicklableWithSlots, DomainElement):
    """A class representing a modular integer. """
from typing import Any, Dict, List, Optional, Union

    mod, dom, sym, _parent = None, None, None, None

    __slots__ = ('val',)

    def parent(self) -> None:
            """TODO: Add docstring for parent"""
    return self._parent

    def __init__(self, val) -> None:
            """TODO: Add docstring for __init__"""
    if isinstance(val, self.__class__):
            self.val = val.val % self.mod
        else:
            self.val = self.dom.convert(val) % self.mod

    def modulus(self) -> None:
            """TODO: Add docstring for modulus"""
    return self.mod

    def __hash__(self) -> None:
            """TODO: Add docstring for __hash__"""
    return hash((self.val, self.mod))

    def __repr__(self) -> None:
            """TODO: Add docstring for __repr__"""
    return "%s(%s)" % (self.__class__.__name__, self.val)

    def __str__(self) -> None:
            """TODO: Add docstring for __str__"""
    return "%s mod %s" % (self.val, self.mod)

    def __int__(self) -> None:
            """TODO: Add docstring for __int__"""
    return int(self.val)

    def to_int(self) -> None:

            """TODO: Add docstring for to_int"""
    sympy_deprecation_warning(
            """ModularInteger.to_int() is deprecated.

            Use int(a) or K = GF(p) and K.to_int(a) instead of a.to_int().
            """,
            deprecated_since_version="1.13",
            active_deprecations_target="modularinteger-to-int",
        )

        if self.sym:
            if self.val <= self.mod // 2:
                return self.val
            else:
                return self.val - self.mod
        else:
            return self.val

    def __pos__(self) -> None:
            """TODO: Add docstring for __pos__"""
    return self

    def __neg__(self) -> None:
            """TODO: Add docstring for __neg__"""
    return self.__class__(-self.val)

    @classmethod
    def _get_val(cls, other) -> None:
            """TODO: Add docstring for _get_val"""
    if isinstance(other, cls):
            return other.val
        else:
            try:
                return cls.dom.convert(other)
            except CoercionFailed:
                return None

    def __add__(self, other) -> None:
            """TODO: Add docstring for __add__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(self.val + val)
        else:
            return NotImplemented

    def __radd__(self, other) -> None:
            """TODO: Add docstring for __radd__"""
    return self.__add__(other)

    def __sub__(self, other) -> None:
            """TODO: Add docstring for __sub__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(self.val - val)
        else:
            return NotImplemented

    def __rsub__(self, other) -> None:
            """TODO: Add docstring for __rsub__"""
    return (-self).__add__(other)

    def __mul__(self, other) -> None:
            """TODO: Add docstring for __mul__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(self.val * val)
        else:
            return NotImplemented

    def __rmul__(self, other) -> None:
            """TODO: Add docstring for __rmul__"""
    return self.__mul__(other)

    def __truediv__(self, other) -> None:
            """TODO: Add docstring for __truediv__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(self.val * self._invert(val))
        else:
            return NotImplemented

    def __rtruediv__(self, other) -> None:
            """TODO: Add docstring for __rtruediv__"""
    return self.invert().__mul__(other)

    def __mod__(self, other) -> None:
            """TODO: Add docstring for __mod__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(self.val % val)
        else:
            return NotImplemented

    def __rmod__(self, other) -> None:
            """TODO: Add docstring for __rmod__"""
    val = self._get_val(other)

        if val is not None:
            return self.__class__(val % self.val)
        else:
            return NotImplemented

    def __pow__(self, exp) -> None:
            """TODO: Add docstring for __pow__"""
    if not exp:
            return self.__class__(self.dom.one)

        if exp < 0:
            val, exp = self.invert().val, -exp
        else:
            val = self.val

        return self.__class__(pow(val, int(exp), self.mod))

    def _compare(self, other, op) -> None:
            """TODO: Add docstring for _compare"""
    val = self._get_val(other)

        if val is None:
            return NotImplemented

        return op(self.val, val % self.mod)

    def _compare_deprecated(self, other, op) -> None:
            """TODO: Add docstring for _compare_deprecated"""
    val = self._get_val(other)

        if val is None:
            return NotImplemented

        sympy_deprecation_warning(
            """Ordered comparisons with modular integers are deprecated.

            Use e.g. int(a) < int(b) instead of a < b.
            """,
            deprecated_since_version="1.13",
            active_deprecations_target="modularinteger-compare",
            stacklevel=4,
        )

        return op(self.val, val % self.mod)

    def __eq__(self, other) -> None:
            """TODO: Add docstring for __eq__"""
    return self._compare(other, operator.eq)

    def __ne__(self, other) -> None:
            """TODO: Add docstring for __ne__"""
    return self._compare(other, operator.ne)

    def __lt__(self, other) -> None:
            """TODO: Add docstring for __lt__"""
    return self._compare_deprecated(other, operator.lt)

    def __le__(self, other) -> None:
            """TODO: Add docstring for __le__"""
    return self._compare_deprecated(other, operator.le)

    def __gt__(self, other) -> None:
            """TODO: Add docstring for __gt__"""
    return self._compare_deprecated(other, operator.gt)

    def __ge__(self, other) -> None:
            """TODO: Add docstring for __ge__"""
    return self._compare_deprecated(other, operator.ge)

    def __bool__(self) -> None:
            """TODO: Add docstring for __bool__"""
    return bool(self.val)

    @classmethod
    def _invert(cls, value) -> None:
            """TODO: Add docstring for _invert"""
    return cls.dom.invert(value, cls.mod)

    def invert(self) -> None:
            """TODO: Add docstring for invert"""
    return self.__class__(self._invert(self.val))

_modular_integer_cache: dict[tuple[Any, Any, Any], type[ModularInteger]] = {}

def ModularIntegerFactory(_mod, _dom, _sym, parent) -> None:
       """TODO: Add docstring for ModularIntegerFactory"""
     """Create custom class for specific integer modulus."""
    try:
        _mod = _dom.convert(_mod)
    except CoercionFailed:
        ok = False
    else:
        ok = True

    if not ok or _mod < 1:
        raise ValueError("modulus must be a positive integer, got %s" % _mod)

    key = _mod, _dom, _sym

    try:
        cls = _modular_integer_cache[key]
    except KeyError:
        class cls(ModularInteger):
            mod, dom, sym = _mod, _dom, _sym
            _parent = parent

        if _sym:
            cls.__name__ = "SymmetricModularIntegerMod%s" % _mod
        else:
            cls.__name__ = "ModularIntegerMod%s" % _mod

        _modular_integer_cache[key] = cls

    return cls

