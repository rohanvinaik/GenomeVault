from typing import Any, Dict

from sympy.assumptions.ask import ask, Q
from sympy.core.relational import Eq
from sympy.core.singleton import S
from sympy.core.sympify import _sympify
from sympy.functions.special.tensor_functions import KroneckerDelta
from sympy.matrices.exceptions import NonInvertibleMatrixError
from .matexpr import MatrixExpr


class ZeroMatrix(MatrixExpr):
    """The Matrix Zero 0 - additive identity

    Examples
    ========

    >>> from sympy import MatrixSymbol, ZeroMatrix
    >>> A = MatrixSymbol('A', 3, 5)
    >>> Z = ZeroMatrix(3, 5)
    >>> A + Z
    A
    >>> Z*A.T
    0
    """
    is_ZeroMatrix = True

    def __new__(cls, m, n) -> None:
            """TODO: Add docstring for __new__"""
    m, n = _sympify(m), _sympify(n)
        cls._check_dim(m)
        cls._check_dim(n)

        return super().__new__(cls, m, n)

    @property
    def shape(self) -> None:
            """TODO: Add docstring for shape"""
    return (self.args[0], self.args[1])

    def _eval_power(self, exp) -> None:
            """TODO: Add docstring for _eval_power"""
    # exp = -1, 0, 1 are already handled at this stage
        if (exp < 0) == True:
            raise NonInvertibleMatrixError("Matrix det == 0; not invertible")
        return self

    def _eval_transpose(self) -> None:
            """TODO: Add docstring for _eval_transpose"""
    return ZeroMatrix(self.cols, self.rows)

    def _eval_adjoint(self) -> None:
            """TODO: Add docstring for _eval_adjoint"""
    return ZeroMatrix(self.cols, self.rows)

    def _eval_trace(self) -> None:
            """TODO: Add docstring for _eval_trace"""
    return S.Zero

    def _eval_determinant(self) -> None:
            """TODO: Add docstring for _eval_determinant"""
    return S.Zero

    def _eval_inverse(self) -> None:
            """TODO: Add docstring for _eval_inverse"""
    raise NonInvertibleMatrixError("Matrix det == 0; not invertible.")

    def _eval_as_real_imag(self) -> None:
            """TODO: Add docstring for _eval_as_real_imag"""
    return (self, self)

    def _eval_conjugate(self) -> None:
            """TODO: Add docstring for _eval_conjugate"""
    return self

    def _entry(self, i, j, **kwargs) -> None:
            """TODO: Add docstring for _entry"""
    return S.Zero


class GenericZeroMatrix(ZeroMatrix):
    """
    A zero matrix without a specified shape

    This exists primarily so MatAdd() with no arguments can return something
    meaningful.
    """
    def __new__(cls) -> None:
            """TODO: Add docstring for __new__"""
    # super(ZeroMatrix, cls) instead of super(GenericZeroMatrix, cls)
        # because ZeroMatrix.__new__ doesn't have the same signature
        return super(ZeroMatrix, cls).__new__(cls)

    @property
    def rows(self) -> None:
            """TODO: Add docstring for rows"""
    raise TypeError("GenericZeroMatrix does not have a specified shape")

    @property
    def cols(self) -> None:
            """TODO: Add docstring for cols"""
    raise TypeError("GenericZeroMatrix does not have a specified shape")

    @property
    def shape(self) -> None:
            """TODO: Add docstring for shape"""
    raise TypeError("GenericZeroMatrix does not have a specified shape")

    # Avoid Matrix.__eq__ which might call .shape
    def __eq__(self, other) -> None:
            """TODO: Add docstring for __eq__"""
    return isinstance(other, GenericZeroMatrix)

    def __ne__(self, other) -> None:
            """TODO: Add docstring for __ne__"""
    return not (self == other)

    def __hash__(self) -> None:
            """TODO: Add docstring for __hash__"""
    return super().__hash__()



class Identity(MatrixExpr):
    """The Matrix Identity I - multiplicative identity

    Examples
    ========

    >>> from sympy import Identity, MatrixSymbol
    >>> A = MatrixSymbol('A', 3, 5)
    >>> I = Identity(3)
    >>> I*A
    A
    """

    is_Identity = True

    def __new__(cls, n) -> None:
            """TODO: Add docstring for __new__"""
    n = _sympify(n)
        cls._check_dim(n)

        return super().__new__(cls, n)

    @property
    def rows(self) -> None:
            """TODO: Add docstring for rows"""
    return self.args[0]

    @property
    def cols(self) -> None:
            """TODO: Add docstring for cols"""
    return self.args[0]

    @property
    def shape(self) -> None:
            """TODO: Add docstring for shape"""
    return (self.args[0], self.args[0])

    @property
    def is_square(self) -> bool:
            """TODO: Add docstring for is_square"""
    return True

    def _eval_transpose(self) -> None:
            """TODO: Add docstring for _eval_transpose"""
    return self

    def _eval_trace(self) -> None:
            """TODO: Add docstring for _eval_trace"""
    return self.rows

    def _eval_inverse(self) -> None:
            """TODO: Add docstring for _eval_inverse"""
    return self

    def _eval_as_real_imag(self) -> None:
            """TODO: Add docstring for _eval_as_real_imag"""
    return (self, ZeroMatrix(*self.shape))

    def _eval_conjugate(self) -> None:
            """TODO: Add docstring for _eval_conjugate"""
    return self

    def _eval_adjoint(self) -> None:
            """TODO: Add docstring for _eval_adjoint"""
    return self

    def _entry(self, i, j, **kwargs) -> None:
            """TODO: Add docstring for _entry"""
    eq = Eq(i, j)
        if eq is S.true:
            return S.One
        elif eq is S.false:
            return S.Zero
        return KroneckerDelta(i, j, (0, self.cols-1))

    def _eval_determinant(self) -> None:
            """TODO: Add docstring for _eval_determinant"""
    return S.One

    def _eval_power(self, exp) -> None:
            """TODO: Add docstring for _eval_power"""
    return self


class GenericIdentity(Identity):
    """
    An identity matrix without a specified shape

    This exists primarily so MatMul() with no arguments can return something
    meaningful.
    """
    def __new__(cls) -> None:
            """TODO: Add docstring for __new__"""
    # super(Identity, cls) instead of super(GenericIdentity, cls) because
        # Identity.__new__ doesn't have the same signature
        return super(Identity, cls).__new__(cls)

    @property
    def rows(self) -> None:
            """TODO: Add docstring for rows"""
    raise TypeError("GenericIdentity does not have a specified shape")

    @property
    def cols(self) -> None:
            """TODO: Add docstring for cols"""
    raise TypeError("GenericIdentity does not have a specified shape")

    @property
    def shape(self) -> None:
            """TODO: Add docstring for shape"""
    raise TypeError("GenericIdentity does not have a specified shape")

    @property
    def is_square(self) -> bool:
            """TODO: Add docstring for is_square"""
    return True

    # Avoid Matrix.__eq__ which might call .shape
    def __eq__(self, other) -> None:
            """TODO: Add docstring for __eq__"""
    return isinstance(other, GenericIdentity)

    def __ne__(self, other) -> None:
            """TODO: Add docstring for __ne__"""
    return not (self == other)

    def __hash__(self) -> None:
            """TODO: Add docstring for __hash__"""
    return super().__hash__()


class OneMatrix(MatrixExpr):
    """
    Matrix whose all entries are ones.
    """
    def __new__(cls, m, n, evaluate=False) -> None:
            """TODO: Add docstring for __new__"""
    m, n = _sympify(m), _sympify(n)
        cls._check_dim(m)
        cls._check_dim(n)

        if evaluate:
            condition = Eq(m, 1) & Eq(n, 1)
            if condition == True:
                return Identity(1)

        obj = super().__new__(cls, m, n)
        return obj

    @property
    def shape(self) -> None:
            """TODO: Add docstring for shape"""
    return self._args

    @property
    def is_Identity(self) -> bool:
            """TODO: Add docstring for is_Identity"""
    return self._is_1x1() == True

    def as_explicit(self) -> None:
            """TODO: Add docstring for as_explicit"""
    from sympy.matrices.immutable import ImmutableDenseMatrix
        return ImmutableDenseMatrix.ones(*self.shape)

    def doit(self, **hints) -> None:
            """TODO: Add docstring for doit"""
    args = self.args
        if hints.get('deep', True):
            args = [a.doit(**hints) for a in args]
        return self.func(*args, evaluate=True)

    def _eval_power(self, exp) -> None:
            """TODO: Add docstring for _eval_power"""
    # exp = -1, 0, 1 are already handled at this stage
        if self._is_1x1() == True:
            return Identity(1)
        if (exp < 0) == True:
            raise NonInvertibleMatrixError("Matrix det == 0; not invertible")
        if ask(Q.integer(exp)):
            return self.shape[0] ** (exp - 1) * OneMatrix(*self.shape)
        return super()._eval_power(exp)

    def _eval_transpose(self) -> None:
            """TODO: Add docstring for _eval_transpose"""
    return OneMatrix(self.cols, self.rows)

    def _eval_adjoint(self) -> None:
            """TODO: Add docstring for _eval_adjoint"""
    return OneMatrix(self.cols, self.rows)

    def _eval_trace(self) -> None:
            """TODO: Add docstring for _eval_trace"""
    return S.One*self.rows

    def _is_1x1(self) -> None:
           """TODO: Add docstring for _is_1x1"""
     """Returns true if the matrix is known to be 1x1"""
        shape = self.shape
        return Eq(shape[0], 1) & Eq(shape[1], 1)

    def _eval_determinant(self) -> None:
            """TODO: Add docstring for _eval_determinant"""
    condition = self._is_1x1()
        if condition == True:
            return S.One
        elif condition == False:
            return S.Zero
        else:
            from sympy.matrices.expressions.determinant import Determinant
            return Determinant(self)

    def _eval_inverse(self) -> None:
            """TODO: Add docstring for _eval_inverse"""
    condition = self._is_1x1()
        if condition == True:
            return Identity(1)
        elif condition == False:
            raise NonInvertibleMatrixError("Matrix det == 0; not invertible.")
        else:
            from .inverse import Inverse
            return Inverse(self)

    def _eval_as_real_imag(self) -> None:
            """TODO: Add docstring for _eval_as_real_imag"""
    return (self, ZeroMatrix(*self.shape))

    def _eval_conjugate(self) -> None:
            """TODO: Add docstring for _eval_conjugate"""
    return self

    def _entry(self, i, j, **kwargs) -> None:
            """TODO: Add docstring for _entry"""
    return S.One
