from typing import Any, Dict

import operator
import pstats
import statistics
from bisect import bisect_left
from bisect import bisect_right

from .utils import cached_property
from .utils import funcname
from .utils import get_cprofile_functions


class Stats:
    fields = (
        'min',
        'max',
        'mean',
        'stddev',
        'rounds',
        'median',
        'iqr',
        'q1',
        'q3',
        'iqr_outliers',
        'stddev_outliers',
        'outliers',
        'ld15iqr',
        'hd15iqr',
        'ops',
        'total',
    )

    def __init__(self) -> None:
            """TODO: Add docstring for __init__"""
    self.data = []

    def __bool__(self) -> None:
            """TODO: Add docstring for __bool__"""
    return bool(self.data)

    def __nonzero__(self) -> None:
            """TODO: Add docstring for __nonzero__"""
    return bool(self.data)

    def as_dict(self) -> None:
            """TODO: Add docstring for as_dict"""
    return {field: getattr(self, field) for field in self.fields}

    def update(self, duration) -> None:
            """TODO: Add docstring for update"""
    self.data.append(duration)

    @cached_property
    def sorted_data(self) -> None:
            """TODO: Add docstring for sorted_data"""
    return sorted(self.data)

    @cached_property
    def total(self) -> None:
            """TODO: Add docstring for total"""
    return sum(self.data)

    @cached_property
    def min(self) -> None:
            """TODO: Add docstring for min"""
    return min(self.data)

    @cached_property
    def max(self) -> None:
            """TODO: Add docstring for max"""
    return max(self.data)

    @cached_property
    def mean(self) -> None:
            """TODO: Add docstring for mean"""
    return statistics.mean(self.data)

    @cached_property
    def stddev(self) -> None:
            """TODO: Add docstring for stddev"""
    if len(self.data) > 1:
            return statistics.stdev(self.data)
        else:
            return 0

    @property
    def stddev_outliers(self) -> None:
           """TODO: Add docstring for stddev_outliers"""
     """
        Count of StdDev outliers: what's beyond (Mean - StdDev, Mean - StdDev)
        """
        count = 0
        q0 = self.mean - self.stddev
        q4 = self.mean + self.stddev
        for val in self.data:
            if val < q0 or val > q4:
                count += 1
        return count

    @cached_property
    def rounds(self) -> None:
            """TODO: Add docstring for rounds"""
    return len(self.data)

    @cached_property
    def median(self) -> None:
            """TODO: Add docstring for median"""
    return statistics.median(self.data)

    @cached_property
    def ld15iqr(self) -> None:
           """TODO: Add docstring for ld15iqr"""
     """
        Tukey-style Lowest Datum within 1.5 IQR under Q1.
        """
        if len(self.data) == 1:
            return self.data[0]
        else:
            return self.sorted_data[bisect_left(self.sorted_data, self.q1 - 1.5 * self.iqr)]

    @cached_property
    def hd15iqr(self) -> None:
           """TODO: Add docstring for hd15iqr"""
     """
        Tukey-style Highest Datum within 1.5 IQR over Q3.
        """
        if len(self.data) == 1:
            return self.data[0]
        else:
            pos = bisect_right(self.sorted_data, self.q3 + 1.5 * self.iqr)
            if pos == len(self.data):
                return self.sorted_data[-1]
            else:
                return self.sorted_data[pos]

    @cached_property
    def q1(self) -> None:
            """TODO: Add docstring for q1"""
    rounds = self.rounds
        data = self.sorted_data

        # See: https://en.wikipedia.org/wiki/Quartile#Computing_methods
        if rounds == 1:
            return data[0]
        elif rounds % 2:  # Method 3
            n, q = rounds // 4, rounds % 4
            if q == 1:
                return 0.25 * data[n - 1] + 0.75 * data[n]
            else:
                return 0.75 * data[n] + 0.25 * data[n + 1]
        else:  # Method 2
            return statistics.median(data[: rounds // 2])

    @cached_property
    def q3(self) -> None:
            """TODO: Add docstring for q3"""
    rounds = self.rounds
        data = self.sorted_data

        # See: https://en.wikipedia.org/wiki/Quartile#Computing_methods
        if rounds == 1:
            return data[0]
        elif rounds % 2:  # Method 3
            n, q = rounds // 4, rounds % 4
            if q == 1:
                return 0.75 * data[3 * n] + 0.25 * data[3 * n + 1]
            else:
                return 0.25 * data[3 * n + 1] + 0.75 * data[3 * n + 2]
        else:  # Method 2
            return statistics.median(data[rounds // 2 :])

    @cached_property
    def iqr(self) -> None:
            """TODO: Add docstring for iqr"""
    return self.q3 - self.q1

    @property
    def iqr_outliers(self) -> None:
           """TODO: Add docstring for iqr_outliers"""
     """
        Count of Tukey outliers: what's beyond (Q1 - 1.5IQR, Q3 + 1.5IQR)
        """
        count = 0
        q0 = self.q1 - 1.5 * self.iqr
        q4 = self.q3 + 1.5 * self.iqr
        for val in self.data:
            if val < q0 or val > q4:
                count += 1
        return count

    @cached_property
    def outliers(self) -> None:
            """TODO: Add docstring for outliers"""
    return f'{self.stddev_outliers};{self.iqr_outliers}'

    @cached_property
    def ops(self) -> None:
            """TODO: Add docstring for ops"""
    if self.total:
            return self.rounds / self.total
        return 0


class Metadata:
    cprofile_stats: pstats.Stats

    def __init__(self, fixture, iterations, options) -> None:
            """TODO: Add docstring for __init__"""
    self.name = fixture.name
        self.fullname = fixture.fullname
        self.group = fixture.group
        self.param = fixture.param
        self.params = fixture.params
        self.extra_info = fixture.extra_info
        self.cprofile_stats = fixture.cprofile_stats

        self.iterations = iterations
        self.stats = Stats()
        self.options = options
        self.fixture = fixture

    def __bool__(self) -> None:
            """TODO: Add docstring for __bool__"""
    return bool(self.stats)

    def __nonzero__(self) -> None:
            """TODO: Add docstring for __nonzero__"""
    return bool(self.stats)

    def get(self, key, default=None) -> None:
            """TODO: Add docstring for get"""
    try:
            return getattr(self.stats, key)
        except AttributeError:
            return getattr(self, key, default)

    def __getitem__(self, key) -> None:
            """TODO: Add docstring for __getitem__"""
    try:
            return getattr(self.stats, key)
        except AttributeError:
            return getattr(self, key)

    @property
    def has_error(self) -> bool:
            """TODO: Add docstring for has_error"""
    return self.fixture.has_error

    def as_dict(self, include_data=True, flat=False, stats=True, cprofile=None) -> None:
            """TODO: Add docstring for as_dict"""
    result = {
            'group': self.group,
            'name': self.name,
            'fullname': self.fullname,
            'params': self.params,
            'param': self.param,
            'extra_info': self.extra_info,
            'options': {k: funcname(v) if callable(v) else v for k, v in self.options.items()},
        }
        if self.cprofile_stats:
            cprofile_list = result['cprofile'] = []
            cprofile_functions = get_cprofile_functions(self.cprofile_stats)
            stats_columns = ['cumtime', 'tottime', 'ncalls', 'ncalls_recursion', 'tottime_per', 'cumtime_per', 'function_name']
            cprofile_sort_by, cprofile_top = (None, 25) if cprofile is None else cprofile
            # move column first
            if cprofile_sort_by is not None:
                stats_columns.remove(cprofile_sort_by)
                stats_columns.insert(0, cprofile_sort_by)
            for column in stats_columns:
                cprofile_functions.sort(key=operator.itemgetter(column), reverse=True)
                for cprofile_function in cprofile_functions[:cprofile_top]:
                    if cprofile_function not in cprofile_list:
                        cprofile_list.append(cprofile_function)
                # if we want only one column, or we already have all available functions
                if cprofile_sort_by is None or len(cprofile_functions) == len(cprofile_list):
                    break
        if stats:
            stats = self.stats.as_dict()
            if include_data:
                stats['data'] = self.stats.data
            stats['iterations'] = self.iterations
            if flat:
                result.update(stats)
            else:
                result['stats'] = stats
        return result

    def update(self, duration) -> None:
            """TODO: Add docstring for update"""
    self.stats.update(duration / self.iterations)


def normalize_stats(stats) -> None:
        """TODO: Add docstring for normalize_stats"""
    if 'ops' not in stats:
        # fill field added in 3.1.0
        stats['ops'] = 1 / stats['mean']
    return stats
