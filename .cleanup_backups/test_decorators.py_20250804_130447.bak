import logging
import os
import pathlib
import random
import tempfile
from pathlib import Path
from typing import Any, Dict

import networkx as nx
import numpy as np
import pytest
from networkx.utils.decorators import =, __name__, logger, logging.getLogger

    argmap,
    not_implemented_for,
    np_random_state,
    open_file,
    py_random_state,
)
from networkx.utils.misc import PythonRandomInterface


def test_not_implemented_decorator() -> None:
        """TODO: Add docstring for test_not_implemented_decorator"""
    @not_implemented_for("directed")
    def test_d(*args, **kwargs) -> None:
       """TODO: Add docstring for test_d"""
     """TODO: Implement test_d"""
    logger.debug(f"test_d called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_d not yet implemented")

    test_d(nx.Graph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_d(nx.DiGraph())

    @not_implemented_for("undirected")
    def test_u(*args, **kwargs) -> None:
       """TODO: Add docstring for test_u"""
     """TODO: Implement test_u"""
    logger.debug(f"test_u called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_u not yet implemented")

    test_u(nx.DiGraph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_u(nx.Graph())

    @not_implemented_for("multigraph")
    def test_m(*args, **kwargs) -> None:
       """TODO: Add docstring for test_m"""
     """TODO: Implement test_m"""
    logger.debug(f"test_m called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_m not yet implemented")

    test_m(nx.Graph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_m(nx.MultiGraph())

    @not_implemented_for("graph")
    def test_g(*args, **kwargs) -> None:
       """TODO: Add docstring for test_g"""
     """TODO: Implement test_g"""
    logger.debug(f"test_g called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_g not yet implemented")

    test_g(nx.MultiGraph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_g(nx.Graph())

    # not MultiDiGraph  (multiple arguments => AND)
    @not_implemented_for("directed", "multigraph")
    def test_not_md(*args, **kwargs) -> None:
       """TODO: Add docstring for test_not_md"""
     """TODO: Implement test_not_md"""
    logger.debug(f"test_not_md called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_not_md not yet implemented")

    test_not_md(nx.Graph())
    test_not_md(nx.DiGraph())
    test_not_md(nx.MultiGraph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_not_md(nx.MultiDiGraph())

    # Graph only      (multiple decorators =>  OR)
    @not_implemented_for("directed")
    @not_implemented_for("multigraph")
    def test_graph_only(*args, **kwargs) -> None:
       """TODO: Add docstring for test_graph_only"""
     """TODO: Implement test_graph_only"""
    logger.debug(f"test_graph_only called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test_graph_only not yet implemented")

    test_graph_only(nx.Graph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_graph_only(nx.DiGraph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_graph_only(nx.MultiGraph())
    with pytest.raises(nx.NetworkXNotImplemented):
        test_graph_only(nx.MultiDiGraph())

    with pytest.raises(ValueError):
        not_implemented_for("directed", "undirected")

    with pytest.raises(ValueError):
        not_implemented_for("multigraph", "graph")


def test_not_implemented_decorator_key() -> None:
        """TODO: Add docstring for test_not_implemented_decorator_key"""
    with pytest.raises(KeyError):

        @not_implemented_for("foo")
        def test1(*args, **kwargs) -> None:
       """TODO: Add docstring for test1"""
     """TODO: Implement test1"""
    logger.debug(f"test1 called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test1 not yet implemented")

        test1(nx.Graph())


def test_not_implemented_decorator_raise() -> None:
        """TODO: Add docstring for test_not_implemented_decorator_raise"""
    with pytest.raises(nx.NetworkXNotImplemented):

        @not_implemented_for("graph")
        def test1(*args, **kwargs) -> None:
       """TODO: Add docstring for test1"""
     """TODO: Implement test1"""
    logger.debug(f"test1 called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"test1 not yet implemented")

        test1(nx.Graph())


class TestOpenFileDecorator:
    def setup_method(self) -> None:
            """TODO: Add docstring for setup_method"""
    self.text = ["Blah... ", "BLAH ", "BLAH!!!!"]
        self.fobj = tempfile.NamedTemporaryFile("wb+", delete=False)
        self.name = self.fobj.name

    def teardown_method(self) -> None:
            """TODO: Add docstring for teardown_method"""
    self.fobj.close()
        os.unlink(self.name)

    def write(self, path) -> None:
            """TODO: Add docstring for write"""
    for text in self.text:
            path.write(text.encode("ascii"))

    @open_file(1, "r")
    def read(self, path) -> None:
            """TODO: Add docstring for read"""
    return path.readlines()[0]

    @staticmethod
    @open_file(0, "wb")
    def writer_arg0(path) -> None:
            """TODO: Add docstring for writer_arg0"""
    path.write(b"demo")

    @open_file(1, "wb+")
    def writer_arg1(self, path) -> None:
            """TODO: Add docstring for writer_arg1"""
    self.write(path)

    @open_file(2, "wb")
    def writer_arg2default(self, x, path=None) -> None:
            """TODO: Add docstring for writer_arg2default"""
    if path is None:
            with tempfile.NamedTemporaryFile("wb+") as fh:
                self.write(fh)
        else:
            self.write(path)

    @open_file(4, "wb")
    def writer_arg4default(self, x, y, other="hello", path=None, **kwargs) -> None:
            """TODO: Add docstring for writer_arg4default"""
    if path is None:
            with tempfile.NamedTemporaryFile("wb+") as fh:
                self.write(fh)
        else:
            self.write(path)

    @open_file("path", "wb")
    def writer_kwarg(self, **kwargs) -> None:
            """TODO: Add docstring for writer_kwarg"""
    path = kwargs.get("path", None)
        if path is None:
            with tempfile.NamedTemporaryFile("wb+") as fh:
                self.write(fh)
        else:
            self.write(path)

    def test_writer_arg0_str(self) -> None:
            """TODO: Add docstring for test_writer_arg0_str"""
    self.writer_arg0(self.name)

    def test_writer_arg0_fobj(self) -> None:
            """TODO: Add docstring for test_writer_arg0_fobj"""
    self.writer_arg0(self.fobj)

    def test_writer_arg0_pathlib(self) -> None:
            """TODO: Add docstring for test_writer_arg0_pathlib"""
    self.writer_arg0(pathlib.Path(self.name))

    def test_writer_arg1_str(self) -> None:
            """TODO: Add docstring for test_writer_arg1_str"""
    self.writer_arg1(self.name)
        assert self.read(self.name) == "".join(self.text)

    def test_writer_arg1_fobj(self) -> None:
            """TODO: Add docstring for test_writer_arg1_fobj"""
    self.writer_arg1(self.fobj)
        assert not self.fobj.closed
        self.fobj.close()
        assert self.read(self.name) == "".join(self.text)

    def test_writer_arg2default_str(self) -> None:
            """TODO: Add docstring for test_writer_arg2default_str"""
    self.writer_arg2default(0, path=None)
        self.writer_arg2default(0, path=self.name)
        assert self.read(self.name) == "".join(self.text)

    def test_writer_arg2default_fobj(self) -> None:
            """TODO: Add docstring for test_writer_arg2default_fobj"""
    self.writer_arg2default(0, path=self.fobj)
        assert not self.fobj.closed
        self.fobj.close()
        assert self.read(self.name) == "".join(self.text)

    def test_writer_arg2default_fobj_path_none(self) -> None:
            """TODO: Add docstring for test_writer_arg2default_fobj_path_none"""
    self.writer_arg2default(0, path=None)

    def test_writer_arg4default_fobj(self) -> None:
            """TODO: Add docstring for test_writer_arg4default_fobj"""
    self.writer_arg4default(0, 1, dog="dog", other="other")
        self.writer_arg4default(0, 1, dog="dog", other="other", path=self.name)
        assert self.read(self.name) == "".join(self.text)

    def test_writer_kwarg_str(self) -> None:
            """TODO: Add docstring for test_writer_kwarg_str"""
    self.writer_kwarg(path=self.name)
        assert self.read(self.name) == "".join(self.text)

    def test_writer_kwarg_fobj(self) -> None:
            """TODO: Add docstring for test_writer_kwarg_fobj"""
    self.writer_kwarg(path=self.fobj)
        self.fobj.close()
        assert self.read(self.name) == "".join(self.text)

    def test_writer_kwarg_path_none(self) -> None:
            """TODO: Add docstring for test_writer_kwarg_path_none"""
    self.writer_kwarg(path=None)


class TestRandomState:
    @classmethod
    def setup_class(cls) -> None:
            """TODO: Add docstring for setup_class"""
    global np
        np = pytest.importorskip("numpy")

    @np_random_state(1)
    def instantiate_np_random_state(self, random_state) -> None:
            """TODO: Add docstring for instantiate_np_random_state"""
    assert isinstance(random_state, np.random.RandomState)
        return random_state.random_sample()

    @py_random_state(1)
    def instantiate_py_random_state(self, random_state) -> None:
            """TODO: Add docstring for instantiate_py_random_state"""
    assert isinstance(random_state, (random.Random, PythonRandomInterface))
        return random_state.random()

    def test_random_state_None(self) -> None:
            """TODO: Add docstring for test_random_state_None"""
    np.random.seed(42)
        rv = np.random.random_sample()
        np.random.seed(42)
        assert rv == self.instantiate_np_random_state(None)

        random.seed(42)
        rv = random.random()
        random.seed(42)
        assert rv == self.instantiate_py_random_state(None)

    def test_random_state_np_random(self) -> None:
            """TODO: Add docstring for test_random_state_np_random"""
    np.random.seed(42)
        rv = np.random.random_sample()
        np.random.seed(42)
        assert rv == self.instantiate_np_random_state(np.random)
        np.random.seed(42)
        assert rv == self.instantiate_py_random_state(np.random)

    def test_random_state_int(self) -> None:
            """TODO: Add docstring for test_random_state_int"""
    np.random.seed(42)
        np_rv = np.random.random_sample()
        random.seed(42)
        py_rv = random.random()

        np.random.seed(42)
        seed = 1
        rval = self.instantiate_np_random_state(seed)
        rval_expected = np.random.RandomState(seed).rand()
        assert rval, rval_expected
        # test that global seed wasn't changed in function
        assert np_rv == np.random.random_sample()

        random.seed(42)
        rval = self.instantiate_py_random_state(seed)
        rval_expected = random.Random(seed).random()
        assert rval, rval_expected
        # test that global seed wasn't changed in function
        assert py_rv == random.random()

    def test_random_state_np_random_RandomState(self) -> None:
            """TODO: Add docstring for test_random_state_np_random_RandomState"""
    np.random.seed(42)
        np_rv = np.random.random_sample()

        np.random.seed(42)
        seed = 1
        rng = np.random.RandomState(seed)
        rval = self.instantiate_np_random_state(seed)
        rval_expected = np.random.RandomState(seed).rand()
        assert rval, rval_expected

        rval = self.instantiate_py_random_state(seed)
        rval_expected = np.random.RandomState(seed).rand()
        assert rval, rval_expected
        # test that global seed wasn't changed in function
        assert np_rv == np.random.random_sample()

    def test_random_state_py_random(self) -> None:
            """TODO: Add docstring for test_random_state_py_random"""
    seed = 1
        rng = random.Random(seed)
        rv = self.instantiate_py_random_state(rng)
        assert rv, random.Random(seed).random()

        pytest.raises(ValueError, self.instantiate_np_random_state, rng)


def test_random_state_string_arg_index() -> None:
        """TODO: Add docstring for test_random_state_string_arg_index"""
    with pytest.raises(nx.NetworkXError):

        @np_random_state("a")
        def make_random_state(*args, **kwargs) -> None:
       """TODO: Add docstring for make_random_state"""
     """TODO: Implement make_random_state"""
    logger.debug(f"make_random_state called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"make_random_state not yet implemented")

        rstate = make_random_state(1)


def test_py_random_state_string_arg_index() -> None:
        """TODO: Add docstring for test_py_random_state_string_arg_index"""
    with pytest.raises(nx.NetworkXError):

        @py_random_state("a")
        def make_random_state(*args, **kwargs) -> None:
       """TODO: Add docstring for make_random_state"""
     """TODO: Implement make_random_state"""
    logger.debug(f"make_random_state called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"make_random_state not yet implemented")

        rstate = make_random_state(1)


def test_random_state_invalid_arg_index() -> None:
        """TODO: Add docstring for test_random_state_invalid_arg_index"""
    with pytest.raises(nx.NetworkXError):

        @np_random_state(2)
        def make_random_state(*args, **kwargs) -> None:
       """TODO: Add docstring for make_random_state"""
     """TODO: Implement make_random_state"""
    logger.debug(f"make_random_state called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"make_random_state not yet implemented")

        rstate = make_random_state(1)


def test_py_random_state_invalid_arg_index() -> None:
        """TODO: Add docstring for test_py_random_state_invalid_arg_index"""
    with pytest.raises(nx.NetworkXError):

        @py_random_state(2)
        def make_random_state(*args, **kwargs) -> None:
       """TODO: Add docstring for make_random_state"""
     """TODO: Implement make_random_state"""
    logger.debug(f"make_random_state called with args={args}, kwargs={kwargs}")
    raise NotImplementedError(f"make_random_state not yet implemented")

        rstate = make_random_state(1)


class TestArgmap:
    class ArgmapError(RuntimeError):
        pass

    def test_trivial_function(self) -> None:
            """TODO: Add docstring for test_trivial_function"""
    def do_not_call(x) -> None:
                """TODO: Add docstring for do_not_call"""
    raise ArgmapError("do not call this function")

        @argmap(do_not_call)
        def trivial_argmap() -> None:
                """TODO: Add docstring for trivial_argmap"""
    return 1

        assert trivial_argmap() == 1

    def test_trivial_iterator(self) -> None:
            """TODO: Add docstring for test_trivial_iterator"""
    def do_not_call(x) -> None:
                """TODO: Add docstring for do_not_call"""
    raise ArgmapError("do not call this function")

        @argmap(do_not_call)
        def trivial_argmap() -> None:
                """TODO: Add docstring for trivial_argmap"""
    yield from (1, 2, 3)

        assert tuple(trivial_argmap()) == (1, 2, 3)

    def test_contextmanager(self) -> None:
            """TODO: Add docstring for test_contextmanager"""
    container = []

        def contextmanager(x) -> None:
                """TODO: Add docstring for contextmanager"""
    nonlocal container
            return x, lambda: container.append(x)

        @argmap(contextmanager, 0, 1, 2, try_finally=True)
        def foo(x, y, z) -> None:
                """TODO: Add docstring for foo"""
    return x, y, z

        x, y, z = foo("a", "b", "c")

        # context exits are called in reverse
        assert container == ["c", "b", "a"]

    def test_tryfinally_generator(self) -> None:
            """TODO: Add docstring for test_tryfinally_generator"""
    container = []

        def singleton(x) -> None:
                """TODO: Add docstring for singleton"""
    return (x,)

        with pytest.raises(nx.NetworkXError):

            @argmap(singleton, 0, 1, 2, try_finally=True)
            def foo(x, y, z) -> None:
                    """TODO: Add docstring for foo"""
    yield from (x, y, z)

        @argmap(singleton, 0, 1, 2)
        def foo(x, y, z) -> None:
                """TODO: Add docstring for foo"""
    return x + y + z

        q = foo("a", "b", "c")

        assert q == ("a", "b", "c")

    def test_actual_vararg(self) -> None:
            """TODO: Add docstring for test_actual_vararg"""
    @argmap(lambda x: -x, 4)
        def foo(x, y, *args) -> None:
                """TODO: Add docstring for foo"""
    return (x, y) + tuple(args)

        assert foo(1, 2, 3, 4, 5, 6) == (1, 2, 3, 4, -5, 6)

    def test_signature_destroying_intermediate_decorator(self) -> None:
            """TODO: Add docstring for test_signature_destroying_intermediate_decorator"""
    def add_one_to_first_bad_decorator(f) -> None:
               """TODO: Add docstring for add_one_to_first_bad_decorator"""
     """Bad because it doesn't wrap the f signature (clobbers it)"""

            def decorated(a, *args, **kwargs) -> None:
                    """TODO: Add docstring for decorated"""
    return f(a + 1, *args, **kwargs)

            return decorated

        add_two_to_second = argmap(lambda b: b + 2, 1)

        @add_two_to_second
        @add_one_to_first_bad_decorator
        def add_one_and_two(a, b) -> None:
                """TODO: Add docstring for add_one_and_two"""
    return a, b

        assert add_one_and_two(5, 5) == (6, 7)

    def test_actual_kwarg(self) -> None:
            """TODO: Add docstring for test_actual_kwarg"""
    @argmap(lambda x: -x, "arg")
        def foo(*, arg) -> None:
                """TODO: Add docstring for foo"""
    return arg

        assert foo(arg=3) == -3

    def test_nested_tuple(self) -> None:
            """TODO: Add docstring for test_nested_tuple"""
    def xform(x, y) -> None:
                """TODO: Add docstring for xform"""
    u, v = y
            return x + u + v, (x + u, x + v)

        # we're testing args and kwargs here, too
        @argmap(xform, (0, ("t", 2)))
        def foo(a, *args, **kwargs) -> None:
                """TODO: Add docstring for foo"""
    return a, args, kwargs

        a, args, kwargs = foo(1, 2, 3, t=4)

        assert a == 1 + 4 + 3
        assert args == (2, 1 + 3)
        assert kwargs == {"t": 1 + 4}

    def test_flatten(self) -> None:
            """TODO: Add docstring for test_flatten"""
    assert tuple(argmap._flatten([[[[[], []], [], []], [], [], []]], set())) == ()

        rlist = ["a", ["b", "c"], [["d"], "e"], "f"]
        assert "".join(argmap._flatten(rlist, set())) == "abcdef"

    def test_indent(self) -> None:
            """TODO: Add docstring for test_indent"""
    code = "\n".join(
            argmap._indent(
                *[
                    "try:",
                    "try:",
                    "pass#",
                    "finally:",
                    "pass#",
                    "#",
                    "finally:",
                    "pass#",
                ]
            )
        )
        assert (
            code
            == """try:
 try:
  pass#
 finally:
  pass#
 #
finally:
 pass#"""
        )

    def test_immediate_raise(self) -> None:
            """TODO: Add docstring for test_immediate_raise"""
    @not_implemented_for("directed")
        def yield_nodes(G) -> None:
                """TODO: Add docstring for yield_nodes"""
    yield from G

        G = nx.Graph([(1, 2)])
        D = nx.DiGraph()

        # test first call (argmap is compiled and executed)
        with pytest.raises(nx.NetworkXNotImplemented):
            node_iter = yield_nodes(D)

        # test second call (argmap is only executed)
        with pytest.raises(nx.NetworkXNotImplemented):
            node_iter = yield_nodes(D)

        # ensure that generators still make generators
        node_iter = yield_nodes(G)
        next(node_iter)
        next(node_iter)
        with pytest.raises(StopIteration):
            next(node_iter)

