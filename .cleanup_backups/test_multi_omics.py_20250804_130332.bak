"""
Comprehensive test suite for multi-omics processors.
"""

import gzip
from pathlib import Path

import numpy as np
import pandas as pd
import pytest

from genomevault.local_processing.epigenetics import (
    ChromatinAccessibilityProcessor, ChromatinPeak, EpigeneticDataType,
    EpigeneticProfile, MethylationContext, MethylationProcessor,
    MethylationSite, create_epigenetic_processor)
from genomevault.local_processing.proteomics import (ModificationType,
                                                     ProteinMeasurement,
                                                     ProteomicsProcessor,
                                                     ProteomicsProfile,
                                                     QuantificationMethod)
from genomevault.local_processing.transcriptomics import (
    ExpressionProfile, NormalizationMethod, TranscriptExpression,
    TranscriptomicsConfig, TranscriptomicsProcessor)


class TestTranscriptomicsProcessor:
    """Test transcriptomics processing functionality."""

    @pytest.fixture
    def processor(self, tmp_path):
        """Create processor instance."""
        config = TranscriptomicsConfig(
            reference_transcriptome=str(tmp_path / "ref.fa"),
            star_index=str(tmp_path / "star"),
            kallisto_index=str(tmp_path / "kallisto.idx"),
            gtf_annotation=str(tmp_path / "genes.gtf"),
            max_threads=2,
        )

        # Create dummy files
        Path(config.star_index).mkdir(exist_ok=True)
        Path(config.kallisto_index).touch()

        return TranscriptomicsProcessor(config)

    @pytest.fixture
    def mock_fastq_files(self, tmp_path):
        """Create mock FASTQ files."""
        fastq1 = tmp_path / "sample_R1.fastq.gz"
        fastq2 = tmp_path / "sample_R2.fastq.gz"

        # Create gzipped FASTQ content
        fastq_content = b"@SEQ1\nACGTACGTACGT\n+\nIIIIIIIIIIII\n" * 1000

        with gzip.open(fastq1, "wb") as f:
            f.write(fastq_content)
        with gzip.open(fastq2, "wb") as f:
            f.write(fastq_content)

        return [str(fastq1), str(fastq2)]

    def test_processor_initialization(self, processor):
        """Test processor initialization."""
        assert processor.config.max_threads == 2
        assert processor.config.normalization_method == "TPM"

    def test_quality_control(self, processor, mock_fastq_files):
        """Test QC on FASTQ files."""
        qc_results = processor._run_quality_control(
            mock_fastq_files, Path(processor.config.star_index).parent
        )

        assert "total_reads" in qc_results
        assert "mean_quality" in qc_results
        assert "gc_content" in qc_results
        assert qc_results["total_reads"] > 0
        assert 0 <= qc_results["gc_content"] <= 1

    def test_normalization_methods(self, processor):
        """Test different normalization methods."""
        # Create mock expression data
        raw_data = pd.DataFrame(
            {
                "gene_id": ["ENSG{i:08d}" for i in range(100)],
                "raw_count": np.random.poisson(100, 100),
            }
        )

        # Test TPM normalization
        tpm_result = processor._normalize_expression(raw_data, NormalizationMethod.TPM)
        assert "normalized_value" in tpm_result.columns
        assert tpm_result["normalized_value"].sum() > 0

        # Test CPM normalization
        cpm_result = processor._normalize_expression(raw_data, NormalizationMethod.CPM)
        assert (cpm_result["normalized_value"] >= 0).all()

    def test_expression_profile_creation(self, processor, tmp_path):
        """Test creating expression profile."""
        # Create mock expression matrix
        expr_file = tmp_path / "expression.tsv"
        expr_data = pd.DataFrame(
            {
                "gene_id": ["ENSG{i:08d}" for i in range(50)],
                "raw_count": np.random.poisson(100, 50),
            }
        )
        expr_data.to_csv(expr_file, sep="\t", index=False)

        # Process
        profile = processor.process(
            expr_file,
            "sample001",
            paired_end=False,
            normalization=NormalizationMethod.TPM,
        )

        assert isinstance(profile, ExpressionProfile)
        assert profile.sample_id == "sample001"
        assert len(profile.expressions) == 50
        assert profile.normalization_method == NormalizationMethod.TPM

    def test_batch_correction(self, processor):
        """Test batch effect correction."""
        # Create mock profiles with batch effects
        profiles = []
        batch_labels = []

        for batch in ["A", "B"]:
            for i in range(3):
                expressions = []
                for j in range(100):
                    # Add batch-specific bias
                    bias = 100 if batch == "A" else 200
                    expr = TranscriptExpression(
                        transcript_id="ENST{j:08d}",
                        gene_id="ENSG{j:08d}",
                        gene_name="GENE{j}",
                        raw_count=np.random.poisson(bias),
                        normalized_value=float(np.random.poisson(bias)),
                        length=1000,
                    )
                    expressions.append(expr)

                profile = ExpressionProfile(
                    sample_id="sample_{batch}_{i}",
                    expressions=expressions,
                    normalization_method=NormalizationMethod.TPM,
                    quality_metrics={},
                )
                profiles.append(profile)
                batch_labels.append(batch)

        # Apply batch correction
        corrected = processor.batch_correction(profiles, batch_labels)

        assert len(corrected) == len(profiles)
        # Check that batch correction was applied
        for profile in corrected:
            assert "batch_corrected" in profile.processing_metadata

    def test_differential_expression(self, processor):
        """Test differential expression analysis."""
        # Create two groups of profiles
        group1_profiles = []
        group2_profiles = []

        # Group 1: Low expression
        for i in range(3):
            expressions = [
                TranscriptExpression(
                    transcript_id="ENST{j:08d}",
                    gene_id="ENSG{j:08d}",
                    gene_name="GENE{j}",
                    raw_count=np.random.poisson(10),
                    normalized_value=float(np.random.poisson(10)),
                    length=1000,
                )
                for j in range(50)
            ]
            profile = ExpressionProfile(
                sample_id="control_{i}",
                expressions=expressions,
                normalization_method=NormalizationMethod.TPM,
                quality_metrics={},
            )
            group1_profiles.append(profile)

        # Group 2: High expression for some genes
        for i in range(3):
            expressions = [
                TranscriptExpression(
                    transcript_id="ENST{j:08d}",
                    gene_id="ENSG{j:08d}",
                    gene_name="GENE{j}",
                    raw_count=np.random.poisson(100 if j < 10 else 10),
                    normalized_value=float(np.random.poisson(100 if j < 10 else 10)),
                    length=1000,
                )
                for j in range(50)
            ]
            profile = ExpressionProfile(
                sample_id="treatment_{i}",
                expressions=expressions,
                normalization_method=NormalizationMethod.TPM,
                quality_metrics={},
            )
            group2_profiles.append(profile)

        # Perform differential expression
        de_results = processor.differential_expression(group1_profiles, group2_profiles)

        assert isinstance(de_results, pd.DataFrame)
        assert "gene_id" in de_results.columns
        assert "log2_fold_change" in de_results.columns
        assert "p_value" in de_results.columns
        assert "fdr" in de_results.columns
        assert "significant" in de_results.columns


class TestEpigeneticsProcessors:
    """Test epigenetics processing functionality."""

    @pytest.fixture
    def methylation_processor(self, tmp_path):
        """Create methylation processor."""
        return MethylationProcessor(
            reference_genome=tmp_path / "ref.fa",
            annotation_file=tmp_path / "genes.gtf",
            min_coverage=5,
        )

    @pytest.fixture
    def chromatin_processor(self, tmp_path):
        """Create chromatin accessibility processor."""
        return ChromatinAccessibilityProcessor(
            reference_genome=tmp_path / "ref.fa", annotation_file=tmp_path / "genes.gtf"
        )

    def test_methylation_processing(self, methylation_processor, tmp_path):
        """Test methylation data processing."""
        # Create mock methylation data file
        meth_file = tmp_path / "methylation.txt"

        # Mock Bismark format data
        with open(meth_file, "w") as f:
            f.write("chr\tpos\tstrand\tmethylated\tunmethylated\tcontext\n")
            for i in range(100):
                f.write("chr1\t{i*1000}\t+\t15\t5\tCG\n")

        # Process
        profile = methylation_processor.process(
            meth_file, "sample001", data_format="bismark", context=MethylationContext.CG
        )

        assert isinstance(profile, EpigeneticProfile)
        assert profile.data_type == EpigeneticDataType.METHYLATION
        assert len(profile.methylation_sites) > 0

        # Test methylation site properties
        site = profile.methylation_sites[0]
        assert isinstance(site, MethylationSite)
        assert 0 <= site.methylation_level <= 1
        assert site.coverage >= methylation_processor.min_coverage

    def test_chromatin_peak_processing(self, chromatin_processor, tmp_path):
        """Test chromatin accessibility processing."""
        # Create mock peak file
        peak_file = tmp_path / "peaks.narrowPeak"
        with open(peak_file, "w") as f:
            for i in range(50):
                # chr start end name score strand signal pvalue qvalue peak
                f.write(
                    "chr1\t{i*10000}\t{i*10000+500}\tpeak{i}\t100\t.\t10.5\t1e-5\t1e-3\t250\n"
                )

        # Process
        profile = chromatin_processor.process(
            peak_file, "sample001", peak_format="narrowPeak"
        )

        assert isinstance(profile, EpigeneticProfile)
        assert profile.data_type == EpigeneticDataType.CHROMATIN_ACCESSIBILITY
        assert len(profile.chromatin_peaks) > 0

        # Test peak properties
        peak = profile.chromatin_peaks[0]
        assert isinstance(peak, ChromatinPeak)
        assert peak.start < peak.end
        assert peak.score > 0

    def test_differential_methylation(self, methylation_processor):
        """Test differential methylation analysis."""
        # Create two groups of methylation profiles
        group1_profiles = []
        group2_profiles = []

        # Group 1: Low methylation
        for i in range(3):
            sites = [
                MethylationSite(
                    chromosome="chr1",
                    position=j * 1000,
                    context=MethylationContext.CG,
                    methylation_level=0.2 + np.random.normal(0, 0.05),
                    coverage=20,
                )
                for j in range(100)
            ]
            profile = EpigeneticProfile(
                sample_id="control_{i}",
                data_type=EpigeneticDataType.METHYLATION,
                methylation_sites=sites,
            )
            group1_profiles.append(profile)

        # Group 2: High methylation
        for i in range(3):
            sites = [
                MethylationSite(
                    chromosome="chr1",
                    position=j * 1000,
                    context=MethylationContext.CG,
                    methylation_level=0.8 + np.random.normal(0, 0.05),
                    coverage=20,
                )
                for j in range(100)
            ]
            profile = EpigeneticProfile(
                sample_id="treatment_{i}",
                data_type=EpigeneticDataType.METHYLATION,
                methylation_sites=sites,
            )
            group2_profiles.append(profile)

        # Perform differential methylation
        dm_results = methylation_processor.differential_methylation(
            group1_profiles, group2_profiles
        )

        assert isinstance(dm_results, pd.DataFrame)
        assert "methylation_difference" in dm_results.columns
        assert len(dm_results[dm_results["significant"]]) > 0

    def test_epigenetic_processor_factory(self):
        """Test processor factory function."""
        # Test methylation processor creation
        meth_proc = create_epigenetic_processor(
            EpigeneticDataType.METHYLATION, min_coverage=10
        )
        assert isinstance(meth_proc, MethylationProcessor)
        assert meth_proc.min_coverage == 10

        # Test chromatin processor creation
        chrom_proc = create_epigenetic_processor(
            EpigeneticDataType.CHROMATIN_ACCESSIBILITY, peak_caller="macs2"
        )
        assert isinstance(chrom_proc, ChromatinAccessibilityProcessor)
        assert chrom_proc.peak_caller == "macs2"


class TestProteomicsProcessor:
    """Test proteomics processing functionality."""

    @pytest.fixture
    def processor(self, tmp_path):
        """Create proteomics processor."""
        return ProteomicsProcessor(
            protein_database=tmp_path / "proteins.fasta",
            min_peptides=2,
            fdr_threshold=0.01,
        )

    def test_protein_measurement_creation(self, processor):
        """Test creating protein measurements."""
        # Create mock protein data
        protein_data = pd.DataFrame(
            {
                "Protein IDs": ["P53_HUMAN", "BRCA1_HUMAN"],
                "Gene names": ["TP53", "BRCA1"],
                "Protein names": ["Tumor protein p53", "Breast cancer type 1"],
                "Peptides": [10, 15],
                "Unique peptides": [8, 12],
                "Sequence coverage [%]": [45.5, 62.3],
                "Intensity": [1e8, 2e8],
                "Score": [250, 380],
                "PEP": [1e-5, 1e-7],
            }
        )

        # Create mock peptide data
        peptide_data = pd.DataFrame(
            {
                "Sequence": ["PEPTIDE1", "PEPTIDE2", "PEPTIDE3"],
                "Proteins": ["P53_HUMAN", "P53_HUMAN", "BRCA1_HUMAN"],
                "Charge": [2, 3, 2],
                "Mass": [1000.5, 1500.7, 1200.3],
                "Retention time": [45.2, 52.1, 48.9],
                "Intensity": [1e6, 2e6, 1.5e6],
                "Score": [50, 75, 60],
                "Modifications": ["", "Phospho (STY)", "Acetyl (K)"],
            }
        )

        # Create measurements
        proteins = processor._create_protein_measurements(protein_data, peptide_data)

        assert len(proteins) == 2
        assert all(isinstance(p, ProteinMeasurement) for p in proteins)

        # Check protein properties
        p53 = next(p for p in proteins if p.protein_id == "P53_HUMAN")
        assert p53.gene_name == "TP53"
        assert p53.num_peptides == 10
        assert p53.sequence_coverage == 45.5

    def test_fdr_filtering(self, processor):
        """Test FDR filtering of proteins."""
        # Create proteins with varying confidence
        proteins = []
        for i in range(100):
            protein = ProteinMeasurement(
                protein_id="PROT{i:04d}",
                gene_name="GENE{i}",
                description="Protein {i}",
                sequence_coverage=50.0,
                num_peptides=5,
                num_unique_peptides=4,
                abundance=1e6 * (i + 1),
                normalized_abundance=1e6 * (i + 1),
                confidence_score=1.0 - (i * 0.01),  # Decreasing confidence
            )
            proteins.append(protein)

        # Apply FDR filter
        filtered = processor._apply_fdr_filter(proteins)

        # Should keep high-confidence proteins
        assert len(filtered) < len(proteins)
        assert all(p.confidence_score > 0.9 for p in filtered[:10])

    def test_abundance_normalization(self, processor):
        """Test protein abundance normalization."""
        # Create proteins with varying abundances
        proteins = [
            ProteinMeasurement(
                protein_id="PROT{i:04d}",
                gene_name="GENE{i}",
                description="Protein {i}",
                sequence_coverage=50.0,
                num_peptides=5,
                num_unique_peptides=4,
                abundance=float(np.random.lognormal(20, 2)),
                normalized_abundance=0.0,
            )
            for i in range(50)
        ]

        # Test label-free normalization
        normalized = processor._normalize_abundances(
            proteins, QuantificationMethod.LABEL_FREE
        )

        # Check normalization worked
        assert all(p.normalized_abundance > 0 for p in normalized)
        # Check relative ordering preserved
        sorted_original = sorted(proteins, key=lambda p: p.abundance)
        sorted_normalized = sorted(normalized, key=lambda p: p.normalized_abundance)
        assert [p.protein_id for p in sorted_original] == [
            p.protein_id for p in sorted_normalized
        ]

    def test_differential_expression(self, processor):
        """Test differential protein expression."""
        # Create two groups with different expression
        group1 = []
        group2 = []

        # Shared proteins with different abundances
        for i in range(3):
            proteins1 = [
                ProteinMeasurement(
                    protein_id="PROT{j:04d}",
                    gene_name="GENE{j}",
                    description="Protein {j}",
                    sequence_coverage=50.0,
                    num_peptides=5,
                    num_unique_peptides=4,
                    abundance=1e6,
                    normalized_abundance=1e6 if j >= 10 else 1e5,  # Low for first 10
                )
                for j in range(20)
            ]

            proteins2 = [
                ProteinMeasurement(
                    protein_id="PROT{j:04d}",
                    gene_name="GENE{j}",
                    description="Protein {j}",
                    sequence_coverage=50.0,
                    num_peptides=5,
                    num_unique_peptides=4,
                    abundance=1e6,
                    normalized_abundance=1e7 if j < 10 else 1e6,  # High for first 10
                )
                for j in range(20)
            ]

            profile1 = ProteomicsProfile(
                sample_id="control_{i}",
                proteins=proteins1,
                quantification_method=QuantificationMethod.LABEL_FREE,
                quality_metrics={},
            )

            profile2 = ProteomicsProfile(
                sample_id="treatment_{i}",
                proteins=proteins2,
                quantification_method=QuantificationMethod.LABEL_FREE,
                quality_metrics={},
            )

            group1.append(profile1)
            group2.append(profile2)

        # Perform differential expression
        de_results = processor.differential_expression(group1, group2)

        assert isinstance(de_results, pd.DataFrame)
        assert "protein_id" in de_results.columns
        assert "log2_fold_change" in de_results.columns
        assert "significant" in de_results.columns

        # First 10 proteins should be significantly different
        significant_proteins = de_results[de_results["significant"]]
        assert len(significant_proteins) > 0

    def test_modification_parsing(self, processor):
        """Test PTM parsing."""
        # Test various modification strings
        mods1 = processor._parse_modifications("Phospho (STY); Acetyl (K)")
        assert len(mods1) == 2
        assert any(m[1] == ModificationType.PHOSPHORYLATION for m in mods1)
        assert any(m[1] == ModificationType.ACETYLATION for m in mods1)

        mods2 = processor._parse_modifications("Oxidation (M)")
        assert len(mods2) == 1
        assert mods2[0][1] == ModificationType.OXIDATION

        mods3 = processor._parse_modifications("")
        assert len(mods3) == 0

    def test_proteomics_profile_methods(self, processor):
        """Test ProteomicsProfile utility methods."""
        # Create profile with diverse proteins
        proteins = [
            ProteinMeasurement(
                protein_id="PROT{i:04d}",
                gene_name="GENE{i}",
                description="Protein {i}",
                sequence_coverage=50.0,
                num_peptides=5,
                num_unique_peptides=4,
                abundance=1e6 * (i + 1),
                normalized_abundance=1e6 * (i + 1),
                modifications={
                    ModificationType.PHOSPHORYLATION: 2 if i < 5 else 0,
                    ModificationType.ACETYLATION: 1 if i % 2 == 0 else 0,
                },
            )
            for i in range(20)
        ]

        profile = ProteomicsProfile(
            sample_id="test_sample",
            proteins=proteins,
            quantification_method=QuantificationMethod.LABEL_FREE,
            quality_metrics={},
        )

        # Test filtering by abundance
        high_abundance = profile.filter_by_abundance(5e6)
        assert len(high_abundance) < len(proteins)
        assert all(p.normalized_abundance >= 5e6 for p in high_abundance)

        # Test getting protein by gene
        gene5 = profile.get_protein_by_gene("GENE5")
        assert gene5 is not None
        assert gene5.protein_id == "PROT0005"

        # Test getting modified proteins
        phospho_proteins = profile.get_modified_proteins(
            ModificationType.PHOSPHORYLATION
        )
        assert len(phospho_proteins) == 5

        # Test pathway enrichment
        pathway_genes = {"GENE0", "GENE1", "GENE2", "GENE10", "GENE99"}
        enrichment = profile.calculate_pathway_enrichment(pathway_genes)
        assert enrichment["overlap_count"] == 4  # GENE99 not in profile
        assert enrichment["pathway_size"] == 5
        assert enrichment["enrichment_ratio"] == 0.8


class TestIntegration:
    """Integration tests for multi-omics processing."""

    def test_multi_omics_processing_pipeline(self, tmp_path):
        """Test processing multiple omics types for same sample."""
        sample_id = "patient_001"

        # Process transcriptomics
        trans_config = TranscriptomicsConfig(
            reference_transcriptome=str(tmp_path / "ref.fa"),
            star_index=str(tmp_path / "star"),
            kallisto_index=str(tmp_path / "kallisto.idx"),
            gtf_annotation=str(tmp_path / "genes.gtf"),
        )
        trans_processor = TranscriptomicsProcessor(trans_config)

        # Create mock expression data
        expr_file = tmp_path / "expression.tsv"
        expr_data = pd.DataFrame(
            {
                "gene_id": ["ENSG{i:08d}" for i in range(100)],
                "raw_count": np.random.poisson(100, 100),
            }
        )
        expr_data.to_csv(expr_file, sep="\t", index=False)

        trans_profile = trans_processor.process(expr_file, sample_id)

        # Process methylation
        meth_processor = MethylationProcessor()
        meth_file = tmp_path / "methylation.txt"

        # Mock methylation data
        with open(meth_file, "w") as f:
            f.write("chr\tpos\tstrand\tmethylated\tunmethylated\tcontext\n")
            for i in range(100):
                f.write("chr1\t{i*10000}\t+\t15\t5\tCG\n")

        meth_profile = meth_processor.process(meth_file, sample_id)

        # Process proteomics
        prot_processor = ProteomicsProcessor()
        prot_file = tmp_path / "proteins.txt"

        # Mock protein data
        prot_data = pd.DataFrame(
            {
                "Protein IDs": ["PROT{i:04d}" for i in range(50)],
                "Gene names": ["GENE{i}" for i in range(50)],
                "Intensity": np.random.lognormal(20, 2, 50),
            }
        )
        prot_data.to_csv(prot_file, sep="\t", index=False)

        # Verify all profiles created successfully
        assert trans_profile.sample_id == sample_id
        assert meth_profile.sample_id == sample_id
        assert len(trans_profile.expressions) > 0
        assert len(meth_profile.methylation_sites) > 0

    def test_error_handling(self, tmp_path):
        """Test error handling in processors."""
        # Test invalid file format
        trans_processor = TranscriptomicsProcessor(
            TranscriptomicsConfig(
                reference_transcriptome="dummy",
                star_index="dummy",
                kallisto_index="dummy",
                gtf_annotation="dummy",
            )
        )

        with pytest.raises(Exception):
            trans_processor.process(tmp_path / "nonexistent.file", "sample001")

        # Test invalid normalization method
        expr_data = pd.DataFrame({"gene_id": ["GENE1"], "raw_count": [100]})

        with pytest.raises(Exception):
            trans_processor._normalize_expression(
                expr_data,
                "INVALID_METHOD",  # This should cause an error
            )


if __name__ == "__main__":
    pytest.main([__file__, "-v"])





