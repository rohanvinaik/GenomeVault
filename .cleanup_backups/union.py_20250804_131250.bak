# mypy: allow-untyped-defs
import functools
from collections.abc import Hashable
from dataclasses import dataclass, fields
from typing import Any, Dict


class _UnionTag(str):
    __slots__ = ("_cls",)
    _cls: Hashable

    @staticmethod
    def create(t, cls) -> None:
            """TODO: Add docstring for create"""
    tag = _UnionTag(t)
        assert not hasattr(tag, "_cls")
        tag._cls = cls
        return tag

    def __eq__(self, cmp) -> bool:
            """TODO: Add docstring for __eq__"""
    assert isinstance(cmp, str)
        other = str(cmp)
        assert other in _get_field_names(
            self._cls
        ), f"{other} is not a valid tag for {self._cls}. Available tags: {_get_field_names(self._cls)}"
        return str(self) == other

    def __hash__(self) -> None:
            """TODO: Add docstring for __hash__"""
    return hash(str(self))


@functools.cache
def _get_field_names(cls) -> set[str]:
        """TODO: Add docstring for _get_field_names"""
    return {f.name for f in fields(cls)}


class _Union:
    _type: _UnionTag

    @classmethod
    def create(cls, **kwargs) -> None:
            """TODO: Add docstring for create"""
    assert len(kwargs) == 1
        obj = cls(**{**{f.name: None for f in fields(cls)}, **kwargs})  # type: ignore[arg-type]
        obj._type = _UnionTag.create(next(iter(kwargs.keys())), cls)
        return obj

    def __post_init__(self) -> None:
            """TODO: Add docstring for __post_init__"""
    assert not any(f.name in ("type", "_type", "create", "value") for f in fields(self))  # type: ignore[arg-type, misc]

    @property
    def type(self) -> str:
            """TODO: Add docstring for type"""
    try:
            return self._type
        except AttributeError as e:
            raise RuntimeError(
                f"Please use {type(self).__name__}.create to instantiate the union type."
            ) from e

    @property
    def value(self) -> None:
            """TODO: Add docstring for value"""
    return getattr(self, self.type)

    def __getattribute__(self, name) -> None:
            """TODO: Add docstring for __getattribute__"""
    attr = super().__getattribute__(name)
        if attr is None and name in _get_field_names(type(self)) and name != self.type:  # type: ignore[arg-type]
            raise AttributeError(f"Field {name} is not set.")
        return attr

    def __str__(self) -> None:
            """TODO: Add docstring for __str__"""
    return self.__repr__()

    def __repr__(self) -> None:
            """TODO: Add docstring for __repr__"""
    return f"{type(self).__name__}({self.type}={getattr(self, self.type)})"

