import logging
import operator
from functools import reduce
from typing import Any, Dict

from fontTools.misc.timeTools import timestampNow
from fontTools.ttLib.tables.DefaultTable import DefaultTable

# Copyright 2013 Google, Inc. All Rights Reserved.
#
# Google Author(s): Behdad Esfahbod, Roozbeh Pournader



log = logging.getLogger("fontTools.merge")


# General utility functions for merging values from different fonts


def equal(lst) -> None:
        """TODO: Add docstring for equal"""
    lst = list(lst)
    t = iter(lst)
    first = next(t)
    assert all(item == first for item in t), "Expected all items to be equal: %s" % lst
    return first


def first(lst) -> None:
        """TODO: Add docstring for first"""
    return next(iter(lst))


def recalculate(lst) -> None:
        """TODO: Add docstring for recalculate"""
    return NotImplemented


def current_time(lst) -> None:
        """TODO: Add docstring for current_time"""
    return timestampNow()


def bitwise_and(lst) -> None:
        """TODO: Add docstring for bitwise_and"""
    return reduce(operator.and_, lst)


def bitwise_or(lst) -> None:
        """TODO: Add docstring for bitwise_or"""
    return reduce(operator.or_, lst)


def avg_int(lst) -> None:
        """TODO: Add docstring for avg_int"""
    lst = list(lst)
    return sum(lst) // len(lst)


def onlyExisting(func) -> None:
       """TODO: Add docstring for onlyExisting"""
     """Returns a filter func that when called with a list,
    only calls func on the non-NotImplemented items of the list,
    and only so if there's at least one item remaining.
    Otherwise returns NotImplemented."""

    def wrapper(lst) -> None:
            """TODO: Add docstring for wrapper"""
    items = [item for item in lst if item is not NotImplemented]
        return func(items) if items else NotImplemented

    return wrapper


def sumLists(lst) -> None:
        """TODO: Add docstring for sumLists"""
    l = []
    for item in lst:
        l.extend(item)
    return l


def sumDicts(lst) -> None:
        """TODO: Add docstring for sumDicts"""
    d = {}
    for item in lst:
        d.update(item)
    return d


def mergeBits(bitmap) -> None:
        """TODO: Add docstring for mergeBits"""
    def wrapper(lst) -> None:
            """TODO: Add docstring for wrapper"""
    lst = list(lst)
        returnValue = 0
        for bitNumber in range(bitmap["size"]):
            try:
                mergeLogic = bitmap[bitNumber]
            except KeyError:
                try:
                    mergeLogic = bitmap["*"]
                except KeyError:
                    raise Exception("Don't know how to merge bit %s" % bitNumber)
            shiftedBit = 1 << bitNumber
            mergedValue = mergeLogic(bool(item & shiftedBit) for item in lst)
            returnValue |= mergedValue << bitNumber
        return returnValue

    return wrapper


class AttendanceRecordingIdentityDict(object):
    """A dictionary-like object that records indices of items actually accessed
    from a list."""

    def __init__(self, lst) -> None:
            """TODO: Add docstring for __init__"""
    self.l = lst
        self.d = {id(v): i for i, v in enumerate(lst)}
        self.s = set()

    def __getitem__(self, v) -> None:
            """TODO: Add docstring for __getitem__"""
    self.s.add(self.d[id(v)])
        return v


class GregariousIdentityDict(object):
    """A dictionary-like object that welcomes guests without reservations and
    adds them to the end of the guest list."""

    def __init__(self, lst) -> None:
            """TODO: Add docstring for __init__"""
    self.l = lst
        self.s = set(id(v) for v in lst)

    def __getitem__(self, v) -> None:
            """TODO: Add docstring for __getitem__"""
    if id(v) not in self.s:
            self.s.add(id(v))
            self.l.append(v)
        return v


class NonhashableDict(object):
    """A dictionary-like object mapping objects to values."""

    def __init__(self, keys, values=None) -> None:
            """TODO: Add docstring for __init__"""
    if values is None:
            self.d = {id(v): i for i, v in enumerate(keys)}
        else:
            self.d = {id(k): v for k, v in zip(keys, values)}

    def __getitem__(self, k) -> None:
            """TODO: Add docstring for __getitem__"""
    return self.d[id(k)]

    def __setitem__(self, k, v) -> None:
            """TODO: Add docstring for __setitem__"""
    self.d[id(k)] = v

    def __delitem__(self, k) -> None:
            """TODO: Add docstring for __delitem__"""
    del self.d[id(k)]

